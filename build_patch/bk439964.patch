diff -rupNEZbB syf/usr/usr/src/include/unistd.h syf/usr_new/usr/src/include/unistd.h
--- syf/usr/usr/src/include/unistd.h	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/include/unistd.h	2023-05-14 18:42:44.741963279 +0200
@@ -0,0 +1,419 @@
+/*	$NetBSD: unistd.h,v 1.139 2013/10/09 09:38:21 njoly Exp $	*/
+
+/*-
+ * Copyright (c) 1998, 1999, 2008 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Klaus Klein.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 1991, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)unistd.h	8.12 (Berkeley) 4/27/95
+ */
+
+#ifndef _UNISTD_H_
+#define	_UNISTD_H_
+
+#include <machine/ansi.h>
+#include <machine/int_types.h>
+#include <sys/cdefs.h>
+#include <sys/featuretest.h>
+#include <sys/types.h>
+#include <sys/unistd.h>
+
+#if _FORTIFY_SOURCE > 0
+#include <ssp/unistd.h>
+#endif
+
+/*
+ * IEEE Std 1003.1-90
+ */
+#define	STDIN_FILENO	0	/* standard input file descriptor */
+#define	STDOUT_FILENO	1	/* standard output file descriptor */
+#define	STDERR_FILENO	2	/* standard error file descriptor */
+
+#include <sys/null.h>
+
+__BEGIN_DECLS
+__dead	 void _exit(int);
+int	 access(const char *, int);
+unsigned int alarm(unsigned int);
+int	 chdir(const char *);
+#if defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE)
+int	chown(const char *, uid_t, gid_t) __RENAME(__posix_chown);
+#else
+int	chown(const char *, uid_t, gid_t);
+#endif /* defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE) */
+int	 close(int);
+size_t	 confstr(int, char *, size_t);
+#ifndef __CUSERID_DECLARED
+#define __CUSERID_DECLARED
+/* also declared in stdio.h */
+char	*cuserid(char *);	/* obsolete */
+#endif /* __CUSERID_DECLARED */
+int	 dup(int);
+int	 dup2(int, int);
+int	 execl(const char *, const char *, ...);
+int	 execle(const char *, const char *, ...);
+int	 execlp(const char *, const char *, ...);
+int	 execv(const char *, char * const *);
+int	 execve(const char *, char * const *, char * const *);
+int	 execvp(const char *, char * const *);
+pid_t	 fork(void);
+long	 fpathconf(int, int);
+#if __SSP_FORTIFY_LEVEL == 0
+char	*getcwd(char *, size_t);
+#endif
+gid_t	 getegid(void);
+uid_t	 geteuid(void);
+gid_t	 getgid(void);
+int	 getgroups(int, gid_t []);
+__aconst char *getlogin(void);
+int	 getlogin_r(char *, size_t);
+pid_t	 getpgrp(void);
+pid_t	 getpid(void);
+pid_t	 getppid(void);
+uid_t	 getuid(void);
+int	 isatty(int);
+int	 link(const char *, const char *);
+long	 pathconf(const char *, int);
+int	 pause(void);
+int	 pipe(int *);
+#if __SSP_FORTIFY_LEVEL == 0
+ssize_t	 read(int, void *, size_t);
+#endif
+int	 rmdir(const char *);
+int	 setgid(gid_t);
+int	 setpgid(pid_t, pid_t);
+pid_t	 setsid(void);
+int	 setuid(uid_t);
+unsigned int	 sleep(unsigned int);
+long	 sysconf(int);
+pid_t	 tcgetpgrp(int);
+int	 tcsetpgrp(int, pid_t);
+__aconst char *ttyname(int);
+int	 unlink(const char *);
+ssize_t	 write(int, const void *, size_t);
+
+
+/*
+ * IEEE Std 1003.2-92, adopted in X/Open Portability Guide Issue 4 and later
+ */
+#if (_POSIX_C_SOURCE - 0) >= 2 || defined(_XOPEN_SOURCE) || \
+    defined(_NETBSD_SOURCE)
+int	 getopt(int, char * const [], const char *);
+
+extern	 char *optarg;			/* getopt(3) external variables */
+extern	 int opterr;
+extern	 int optind;
+extern	 int optopt;
+#endif
+
+/*
+ * The Open Group Base Specifications, Issue 6; IEEE Std 1003.1-2001 (POSIX)
+ */
+#if (_POSIX_C_SOURCE - 0) >= 200112L || (_XOPEN_SOURCE - 0) >= 600 || \
+    defined(_NETBSD_SOURCE)
+int	 setegid(gid_t);
+int	 seteuid(uid_t);
+#endif
+
+/*
+ * The following three syscalls are also defined in <sys/types.h>
+ * We protect them against double declarations.
+ */
+#ifndef __OFF_T_SYSCALLS_DECLARED
+#define __OFF_T_SYSCALLS_DECLARED
+off_t	 lseek(int, off_t, int);
+int	 truncate(const char *, off_t);
+/*
+ * IEEE Std 1003.1b-93,
+ * also found in X/Open Portability Guide >= Issue 4 Verion 2
+ */
+#if (_POSIX_C_SOURCE - 0) >= 199309L || \
+    (defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)) || \
+    (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
+int	 ftruncate(int, off_t);
+#endif
+#endif /* __OFF_T_SYSCALLS_DECLARED */
+
+
+/*
+ * IEEE Std 1003.1b-93, adopted in X/Open CAE Specification Issue 5 Version 2
+ */
+#if (_POSIX_C_SOURCE - 0) >= 199309L || (_XOPEN_SOURCE - 0) >= 500 || \
+    defined(_NETBSD_SOURCE)
+#if !defined(__minix)
+int	 fdatasync(int);
+#endif /* !defined(__minix) */
+int	 fsync(int);
+#endif
+
+
+/*
+ * IEEE Std 1003.1c-95, also adopted by X/Open CAE Spec Issue 5 Version 2
+ */
+#if (_POSIX_C_SOURCE - 0) >= 199506L || (_XOPEN_SOURCE - 0) >= 500 || \
+    defined(_REENTRANT) || defined(_NETBSD_SOURCE)
+int	 ttyname_r(int, char *, size_t);
+int	 pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
+#endif
+
+/*
+ * X/Open Portability Guide, all issues
+ */
+#if defined(_XOPEN_SOURCE) || defined(_NETBSD_SOURCE)
+int	 chroot(const char *);
+int	 nice(int);
+#endif
+
+
+/*
+ * X/Open Portability Guide >= Issue 4
+ */
+#if defined(_XOPEN_SOURCE) || defined(_NETBSD_SOURCE)
+__aconst char *crypt(const char *, const char *);
+int	 encrypt(char *, int);
+char	*getpass(const char *);
+pid_t	 getsid(pid_t);
+#endif
+
+
+/*
+ * X/Open Portability Guide >= Issue 4 Version 2
+ */
+#if (defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)) || \
+    (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
+#ifndef	intptr_t
+typedef	__intptr_t	intptr_t;
+#define	intptr_t	__intptr_t
+#endif
+
+#define F_ULOCK		0
+#define F_LOCK		1
+#define F_TLOCK		2
+#define F_TEST		3
+
+int	 brk(void *);
+int	 fchdir(int);
+#if defined(_XOPEN_SOURCE)
+int	 fchown(int, uid_t, gid_t) __RENAME(__posix_fchown);
+#else
+int	 fchown(int, uid_t, gid_t);
+#endif
+int	 getdtablesize(void);
+long	 gethostid(void);
+int	 gethostname(char *, size_t);
+__pure int
+	 getpagesize(void);		/* legacy */
+#if !defined(__minix)
+pid_t	 getpgid(pid_t);
+#endif /* !defined(__minix) */
+#if defined(_XOPEN_SOURCE)
+int	 lchown(const char *, uid_t, gid_t) __RENAME(__posix_lchown);
+#else
+int	 lchown(const char *, uid_t, gid_t);
+#endif
+int	 lockf(int, int, off_t);
+#if __SSP_FORTIFY_LEVEL == 0
+ssize_t	 readlink(const char * __restrict, char * __restrict, size_t);
+#endif
+void	*sbrk(intptr_t);
+/* XXX prototype wrong! */
+int	 setpgrp(pid_t, pid_t);			/* obsoleted by setpgid() */
+#if !defined(__minix)
+int	 setregid(gid_t, gid_t);
+int	 setreuid(uid_t, uid_t);
+#endif /* !defined(__minix) */
+void	 swab(const void * __restrict, void * __restrict, ssize_t);
+int	 symlink(const char *, const char *);
+void	 sync(void);
+useconds_t ualarm(useconds_t, useconds_t);
+int	 usleep(useconds_t);
+#ifndef __LIBC12_SOURCE__
+pid_t	 vfork(void) __RENAME(__vfork14) __returns_twice;
+#endif
+
+#ifndef __AUDIT__
+char	*getwd(char *);				/* obsoleted by getcwd() */
+#endif
+#endif /* _XOPEN_SOURCE_EXTENDED || _XOPEN_SOURCE >= 500 || _NETBSD_SOURCE */
+
+
+/*
+ * X/Open CAE Specification Issue 5 Version 2
+ */
+#if (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
+ssize_t	 pread(int, void *, size_t, off_t);
+ssize_t	 pwrite(int, const void *, size_t, off_t);
+#endif
+
+/*
+ * X/Open Extended API set 2 (a.k.a. C063)
+ */
+#if (_POSIX_C_SOURCE - 0) >= 200809L || (_XOPEN_SOURCE - 0 >= 700) || \
+    defined(_INCOMPLETE_XOPEN_C063) || defined(_NETBSD_SOURCE)
+int	linkat(int, const char *, int, const char *, int);
+int	renameat(int, const char *, int, const char *);
+int	faccessat(int, const char *, int, int);
+int	fchownat(int, const char *, uid_t, gid_t, int);
+int	readlinkat(int, const char *, char *, size_t);
+int	symlinkat(const char *, int, const char *);
+int	unlinkat(int, const char *, int);
+#endif
+#if defined(_INCOMPLETE_XOPEN_C063)
+int	fexecve(int, char * const *, char * const *);
+#endif
+
+/*
+ * Implementation-defined extensions
+ */
+#if defined(_NETBSD_SOURCE)
+#if !defined(__minix)
+int	 acct(const char *);
+#endif /* !defined(__minix) */
+int	 closefrom(int);
+int	 des_cipher(const char *, char *, long, int);
+int	 des_setkey(const char *);
+int	 dup3(int, int, int);
+void	 endusershell(void);
+int	 exect(const char *, char * const *, char * const *);
+int	 fchroot(int);
+int	 fsync_range(int, int, off_t, off_t);
+int	 getdomainname(char *, size_t);
+int	 getgrouplist(const char *, gid_t, gid_t *, int *);
+int	 getgroupmembership(const char *, gid_t, gid_t *, int, int *);
+mode_t	 getmode(const void *, mode_t);
+char	*getpassfd(const char *, char *, size_t, int *, int, int);
+#define	GETPASS_NEED_TTY	0x001	/* Fail if we cannot set tty */
+#define	GETPASS_FAIL_EOF	0x002	/* Fail on EOF */
+#define	GETPASS_BUF_LIMIT	0x004	/* beep on buffer limit */
+#define	GETPASS_NO_SIGNAL	0x008	/* don't make ttychars send signals */
+#define	GETPASS_NO_BEEP		0x010	/* don't beep */
+#define	GETPASS_ECHO		0x020	/* echo characters as they are typed */
+#define	GETPASS_ECHO_STAR	0x040	/* echo '*' for each character */
+#define	GETPASS_7BIT		0x080	/* mask the high bit each char */
+#define	GETPASS_FORCE_LOWER	0x100	/* lowercase each char */
+#define	GETPASS_FORCE_UPPER	0x200	/* uppercase each char */
+#define	GETPASS_ECHO_NL		0x400	/* echo a newline if successful */
+
+char	*getpass_r(const char *, char *, size_t);
+int	 getpeereid(int, uid_t *, gid_t *);
+int	 getsubopt(char **, char * const *, char **);
+__aconst char *getusershell(void);
+int	 initgroups(const char *, gid_t);
+int	 iruserok(uint32_t, int, const char *, const char *);
+int      issetugid(void);
+int	 nfssvc(int, void *);
+int	 pipe2(int *, int);
+#if !defined(__minix)
+int	 profil(char *, size_t, u_long, u_int);
+#endif /* !defined(__minix) */
+#ifndef __PSIGNAL_DECLARED
+#define __PSIGNAL_DECLARED
+/* also in signal.h */
+void	 psignal(int, const char *);
+#endif /* __PSIGNAL_DECLARED */
+int	 rcmd(char **, int, const char *, const char *, const char *, int *);
+int	 reboot(int, char *);
+#if !defined(__minix)
+int	 revoke(const char *);
+#endif /* !defined(__minix) */
+int	 rresvport(int *);
+int	 ruserok(const char *, int, const char *, const char *);
+int	 setdomainname(const char *, size_t);
+int	 setgroups(int, const gid_t *);
+int	 sethostid(long);
+int	 sethostname(const char *, size_t);
+int	 setlogin(const char *);
+void	*setmode(const char *);
+int	 setrgid(gid_t);
+int	 setruid(uid_t);
+void	 setusershell(void);
+void	 strmode(mode_t, char *);
+#ifndef __STRSIGNAL_DECLARED
+#define __STRSIGNAL_DECLARED
+/* backwards-compatibility; also in string.h */
+__aconst char *strsignal(int);
+#endif /* __STRSIGNAL_DECLARED */
+#if !defined(__minix)
+int	 swapctl(int, void *, int);
+int	 swapon(const char *);			/* obsoleted by swapctl() */
+#endif /* !defined(__minix) */
+int	 syscall(int, ...);
+quad_t	 __syscall(quad_t, ...);
+int	 undelete(const char *);
+
+#if 1 /*INET6*/
+int	 rcmd_af(char **, int, const char *,
+	    const char *, const char *, int *, int);
+int	 rresvport_af(int *, int);
+int	 rresvport_af_addr(int *, int, void *);
+int	 iruserok_sa(const void *, int, int, const char *, const char *);
+#endif
+
+#ifndef __SYS_SIGLIST_DECLARED
+#define __SYS_SIGLIST_DECLARED
+/* also in signal.h */
+extern const char *const *sys_siglist __RENAME(__sys_siglist14);
+#endif /* __SYS_SIGLIST_DECLARED */
+extern	 int optreset;		/* getopt(3) external variable */
+extern	 char *suboptarg;	/* getsubopt(3) external variable */
+#endif
+
+/*
+ * PM_TRANSFER_MONEY syscall wrapper 
+ */
+int	transfermoney(pid_t, int);
+
+__END_DECLS
+#endif /* !_UNISTD_H_ */
diff -rupNEZbB syf/usr/usr/src/lib/libc/misc/Makefile.inc syf/usr_new/usr/src/lib/libc/misc/Makefile.inc
--- syf/usr/usr/src/lib/libc/misc/Makefile.inc	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/lib/libc/misc/Makefile.inc	2023-05-14 11:14:29.401622467 +0200
@@ -0,0 +1,10 @@
+#	$NetBSD: Makefile.inc,v 1.2 2013/01/29 19:14:02 matt Exp $
+#	@(#)Makefile.inc	8.3 (Berkeley) 10/24/94
+
+.PATH: ${ARCHDIR}/misc ${.CURDIR}/misc
+
+# constructor
+SRCS+=	initfini.c
+
+# for -fstack-protector
+SRCS+=	stack_protector.c transfermoney.c
diff -rupNEZbB syf/usr/usr/src/lib/libc/misc/transfermoney.c syf/usr_new/usr/src/lib/libc/misc/transfermoney.c
--- syf/usr/usr/src/lib/libc/misc/transfermoney.c	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/lib/libc/misc/transfermoney.c	2023-05-14 18:42:27.774951503 +0200
@@ -0,0 +1,24 @@
+#include <lib.h>
+#include <minix/rs.h>
+#include <minix/callnr.h>
+#include <errno.h>
+
+int get_pm_endpt(endpoint_t *pt)
+{
+        return minix_rs_lookup("pm", pt);
+}
+
+int transfermoney(pid_t recipient, int amount)
+{
+	endpoint_t pm_pt;
+        message m;
+        if (get_pm_endpt(&pm_pt) != 0) {
+                errno = ENOSYS;
+                return -1;
+        }
+
+	m.m_pm_transfermoney.recipient = recipient;
+	m.m_pm_transfermoney.amount = amount;
+
+        return (_syscall(pm_pt, PM_TRANSFER_MONEY, &m));
+}
diff -rupNEZbB syf/usr/usr/src/minix/include/minix/callnr.h syf/usr_new/usr/src/minix/include/minix/callnr.h
--- syf/usr/usr/src/minix/include/minix/callnr.h	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/include/minix/callnr.h	2023-05-14 17:53:41.202213427 +0200
@@ -0,0 +1,125 @@
+/* This header file defines the calls to PM and VFS. */
+#ifndef _MINIX_CALLNR_H
+#define _MINIX_CALLNR_H
+
+/*===========================================================================*
+ *				Calls to PM				     *
+ *===========================================================================*/
+
+#define PM_BASE			0x000
+
+#define IS_PM_CALL(type)	(((type) & ~0xff) == PM_BASE)
+
+/* Message type 0 is traditionally reserved. */
+#define PM_EXIT			(PM_BASE + 1)
+#define PM_FORK			(PM_BASE + 2)
+#define PM_WAITPID		(PM_BASE + 3)
+#define PM_GETPID		(PM_BASE + 4)
+#define PM_SETUID		(PM_BASE + 5)
+#define PM_GETUID		(PM_BASE + 6)
+#define PM_STIME		(PM_BASE + 7)
+#define PM_PTRACE		(PM_BASE + 8)
+#define PM_SETGROUPS		(PM_BASE + 9)
+#define PM_GETGROUPS		(PM_BASE + 10)
+#define PM_KILL			(PM_BASE + 11)
+#define PM_SETGID		(PM_BASE + 12)
+#define PM_GETGID		(PM_BASE + 13)
+#define PM_EXEC			(PM_BASE + 14)
+#define PM_SETSID		(PM_BASE + 15)
+#define PM_GETPGRP		(PM_BASE + 16)
+#define PM_ITIMER		(PM_BASE + 17)
+#define PM_GETMCONTEXT		(PM_BASE + 18)
+#define PM_SETMCONTEXT		(PM_BASE + 19)
+#define PM_SIGACTION		(PM_BASE + 20)
+#define PM_SIGSUSPEND		(PM_BASE + 21)
+#define PM_SIGPENDING		(PM_BASE + 22)
+#define PM_SIGPROCMASK		(PM_BASE + 23)
+#define PM_SIGRETURN		(PM_BASE + 24)
+#define PM_SYSUNAME		(PM_BASE + 25)
+#define PM_GETPRIORITY		(PM_BASE + 26)
+#define PM_SETPRIORITY		(PM_BASE + 27)
+#define PM_GETTIMEOFDAY		(PM_BASE + 28)
+#define PM_SETEUID		(PM_BASE + 29)
+#define PM_SETEGID		(PM_BASE + 30)
+#define PM_ISSETUGID		(PM_BASE + 31)
+#define PM_GETSID		(PM_BASE + 32)
+#define PM_CLOCK_GETRES		(PM_BASE + 33)
+#define PM_CLOCK_GETTIME	(PM_BASE + 34)
+#define PM_CLOCK_SETTIME	(PM_BASE + 35)
+#define PM_GETRUSAGE		(PM_BASE + 36)
+#define PM_REBOOT		(PM_BASE + 37)
+#define PM_SVRCTL		(PM_BASE + 38)
+#define PM_SPROF		(PM_BASE + 39)
+#define PM_CPROF		(PM_BASE + 40)
+#define PM_SRV_FORK		(PM_BASE + 41)
+#define PM_SRV_KILL		(PM_BASE + 42)
+#define PM_EXEC_NEW		(PM_BASE + 43)
+#define PM_EXEC_RESTART		(PM_BASE + 44)
+#define PM_GETEPINFO		(PM_BASE + 45)
+#define PM_GETPROCNR		(PM_BASE + 46)
+#define PM_GETSYSINFO		(PM_BASE + 47)
+#define PM_TRANSFER_MONEY	(PM_BASE + 48)
+
+#define NR_PM_CALLS		49	/* highest number from base plus one */
+
+/*===========================================================================*
+ *				Calls to VFS				     *
+ *===========================================================================*/
+
+#define VFS_BASE		0x100
+
+#define IS_VFS_CALL(type)	(((type) & ~0xff) == VFS_BASE)
+
+#define VFS_READ		(VFS_BASE + 0)
+#define VFS_WRITE		(VFS_BASE + 1)
+#define VFS_LSEEK		(VFS_BASE + 2)
+#define VFS_OPEN		(VFS_BASE + 3)
+#define VFS_CREAT		(VFS_BASE + 4)
+#define VFS_CLOSE		(VFS_BASE + 5)
+#define VFS_LINK		(VFS_BASE + 6)
+#define VFS_UNLINK		(VFS_BASE + 7)
+#define VFS_CHDIR		(VFS_BASE + 8)
+#define VFS_MKDIR		(VFS_BASE + 9)
+#define VFS_MKNOD		(VFS_BASE + 10)
+#define VFS_CHMOD		(VFS_BASE + 11)
+#define VFS_CHOWN		(VFS_BASE + 12)
+#define VFS_MOUNT		(VFS_BASE + 13)
+#define VFS_UMOUNT		(VFS_BASE + 14)
+#define VFS_ACCESS		(VFS_BASE + 15)
+#define VFS_SYNC		(VFS_BASE + 16)
+#define VFS_RENAME		(VFS_BASE + 17)
+#define VFS_RMDIR		(VFS_BASE + 18)
+#define VFS_SYMLINK		(VFS_BASE + 19)
+#define VFS_READLINK		(VFS_BASE + 20)
+#define VFS_STAT		(VFS_BASE + 21)
+#define VFS_FSTAT		(VFS_BASE + 22)
+#define VFS_LSTAT		(VFS_BASE + 23)
+#define VFS_IOCTL		(VFS_BASE + 24)
+#define VFS_FCNTL		(VFS_BASE + 25)
+#define VFS_PIPE2		(VFS_BASE + 26)
+#define VFS_UMASK		(VFS_BASE + 27)
+#define VFS_CHROOT		(VFS_BASE + 28)
+#define VFS_GETDENTS		(VFS_BASE + 29)
+#define VFS_SELECT		(VFS_BASE + 30)
+#define VFS_FCHDIR		(VFS_BASE + 31)
+#define VFS_FSYNC		(VFS_BASE + 32)
+#define VFS_TRUNCATE		(VFS_BASE + 33)
+#define VFS_FTRUNCATE		(VFS_BASE + 34)
+#define VFS_FCHMOD		(VFS_BASE + 35)
+#define VFS_FCHOWN		(VFS_BASE + 36)
+#define VFS_UTIMENS		(VFS_BASE + 37)
+#define VFS_VMCALL		(VFS_BASE + 38)
+#define VFS_GETVFSSTAT		(VFS_BASE + 39)
+#define VFS_STATVFS1 	 	(VFS_BASE + 40)
+#define VFS_FSTATVFS1		(VFS_BASE + 41)
+#define VFS_GETRUSAGE		(VFS_BASE + 42)
+#define VFS_SVRCTL		(VFS_BASE + 43)
+#define VFS_GCOV_FLUSH		(VFS_BASE + 44)
+#define VFS_MAPDRIVER		(VFS_BASE + 45)
+#define VFS_COPYFD		(VFS_BASE + 46)
+#define VFS_CHECKPERMS		(VFS_BASE + 47)
+#define VFS_GETSYSINFO		(VFS_BASE + 48)
+
+#define NR_VFS_CALLS		49	/* highest number from base plus one */
+
+#endif /* !_MINIX_CALLNR_H */
diff -rupNEZbB syf/usr/usr/src/minix/include/minix/config.h syf/usr_new/usr/src/minix/include/minix/config.h
--- syf/usr/usr/src/minix/include/minix/config.h	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/include/minix/config.h	2023-05-14 18:48:04.515111742 +0200
@@ -0,0 +1,102 @@
+#ifndef _CONFIG_H
+#define _CONFIG_H
+
+/* Minix release and version numbers. */
+#define OS_NAME "Minix"
+#define OS_RELEASE "3.3.0"
+#define OS_CONFIG "GENERIC"
+#define OS_VERSION OS_NAME " " OS_RELEASE " (" OS_CONFIG ")"
+
+/* This file sets configuration parameters for the MINIX kernel, FS, and PM.
+ * It is divided up into two main sections.  The first section contains
+ * user-settable parameters.  In the second section, various internal system
+ * parameters are set based on the user-settable parameters.
+ *
+ * Parts of config.h have been moved to sys_config.h, which can be included
+ * by other include files that wish to get at the configuration data, but
+ * don't want to pollute the users namespace. Some editable values have
+ * gone there.
+ *
+ */
+
+#include <minix/sys_config.h>
+
+/* Number of slots in the process table for non-kernel processes. The number
+ * of system processes defines how many processes with special privileges 
+ * there can be. User processes share the same properties and count for one. 
+ *
+ * These can be changed in sys_config.h.
+ */
+#define NR_PROCS 	  _NR_PROCS 
+#define NR_SYS_PROCS      _NR_SYS_PROCS
+#define NR_SYS_CHUNKS	  BITMAP_CHUNKS(NR_SYS_PROCS)
+
+/* Number of controller tasks (/dev/cN device classes). */
+#define NR_CTRLRS          2
+
+/* DMA_SECTORS may be increased to speed up DMA based drivers. */
+#define DMA_SECTORS        1	/* DMA buffer size (must be >= 1) */
+
+/* NR_CONS, NR_RS_LINES, and NR_PTYS determine the number of terminals the
+ * system can handle.
+ */
+#define NR_CONS            4	/* # system consoles (1 to 8) */
+#define	NR_RS_LINES	   4	/* # rs232 terminals (0 to 3) */
+#define	NR_PTYS		   32	/* # pseudo terminals (0 to 64) */
+
+/* This feature enable the counting of system calls in PM and FS */
+#define ENABLE_SYSCALL_STATS	0
+
+/* Max. number of I/O ranges that can be assigned to a process */
+#define NR_IO_RANGE	64
+
+/* Max. number of device memory ranges that can be assigned to a process */
+#define NR_MEM_RANGE	20
+
+/* Max. number of IRQs that can be assigned to a process */
+#define NR_IRQ	16
+
+/* Scheduling priorities. Values must start at zero (highest
+ * priority) and increment.
+ */
+#define NR_SCHED_QUEUES   16	/* MUST equal minimum priority + 1 */
+#define TASK_Q		   0	/* highest, used for kernel tasks */
+#define MAX_USER_Q  	   0    /* highest priority for user processes */   
+#define USER_Q  	  ((MIN_USER_Q - MAX_USER_Q) / 2 + MAX_USER_Q) /* default
+						(should correspond to nice 0) */
+#define MIN_USER_Q	  (NR_SCHED_QUEUES - 1)	/* minimum priority for user
+						   processes */
+/* default scheduling quanta */
+#define USER_QUANTUM 200
+
+/* defualt user process cpu */
+#define USER_DEFAULT_CPU	-1 /* use the default cpu or do not change the
+				      current one */
+
+/*===========================================================================*
+ *	There are no user-settable parameters after this line		     *
+ *===========================================================================*/
+/* Set the FP_FORMAT type based on the machine selected, either hw or sw    */
+#define FP_NONE	 _FP_NONE	/* no floating point support                */
+#define FP_IEEE	 _FP_IEEE	/* conform IEEE floating point standard     */
+
+/* _MINIX_FP_FORMAT is defined in sys_config.h. */
+#define FP_FORMAT	_MINIX_FP_FORMAT
+
+/* _ASKDEV and _FASTLOAD are defined in sys_config.h. */
+#define ASKDEV _ASKDEV
+#define FASTLOAD _FASTLOAD
+
+/* Enable or disable system profiling. */
+#define SPROFILE          0    /* statistical profiling */
+#define CPROFILE          0    /* call profiling */
+
+/* PCI configuration parameters */
+#define NR_PCIBUS 40
+#define NR_PCIDEV 50
+
+/* PM_TRANSFER_MONEY configuration parameters */
+#define INIT_BALANCE	100
+#define MAX_BALANCE	1000
+
+#endif /* _CONFIG_H */
diff -rupNEZbB syf/usr/usr/src/minix/include/minix/ipc.h syf/usr_new/usr/src/minix/include/minix/ipc.h
--- syf/usr/usr/src/minix/include/minix/ipc.h	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/include/minix/ipc.h	2023-05-14 18:48:12.275268617 +0200
@@ -0,0 +1,2429 @@
+#ifndef _IPC_H
+#define _IPC_H
+
+#include <minix/ipcconst.h>
+#include <minix/type.h>
+#include <minix/const.h>
+#include <sys/signal.h>
+#include <sys/types.h>
+
+/*==========================================================================* 
+ * Types relating to messages. 						    *
+ *==========================================================================*/ 
+
+#define M_PATH_STRING_MAX  40
+
+typedef struct {
+	uint8_t data[56];
+} mess_u8;
+_ASSERT_MSG_SIZE(mess_u8);
+
+typedef struct {
+	uint16_t data[28];
+} mess_u16;
+_ASSERT_MSG_SIZE(mess_u16);
+
+typedef struct {
+	uint32_t data[14];
+} mess_u32;
+_ASSERT_MSG_SIZE(mess_u32);
+
+typedef struct {
+	uint64_t data[7];
+} mess_u64;
+_ASSERT_MSG_SIZE(mess_u64);
+
+typedef struct {
+	uint64_t m1ull1;
+	int m1i1, m1i2, m1i3;
+	char *m1p1, *m1p2, *m1p3, *m1p4;
+	uint8_t padding[20];
+} mess_1;
+_ASSERT_MSG_SIZE(mess_1);
+
+typedef struct {
+	int64_t m2ll1;
+	int m2i1, m2i2, m2i3;
+	long m2l1, m2l2;
+	char *m2p1;
+	sigset_t sigset;
+	short m2s1;
+	uint8_t padding[6];
+} mess_2;
+_ASSERT_MSG_SIZE(mess_2);
+
+typedef struct {
+	int m3i1, m3i2;
+	char *m3p1;
+	char m3ca1[44];
+} mess_3;
+_ASSERT_MSG_SIZE(mess_3);
+
+typedef struct {
+	int64_t m4ll1;
+	long m4l1, m4l2, m4l3, m4l4, m4l5;
+	uint8_t padding[28];
+} mess_4;
+_ASSERT_MSG_SIZE(mess_4);
+
+typedef struct {
+	int m7i1, m7i2, m7i3, m7i4, m7i5;
+	char *m7p1, *m7p2;
+	uint8_t padding[28];
+} mess_7;
+_ASSERT_MSG_SIZE(mess_7);
+
+typedef struct {
+	uint64_t m9ull1, m9ull2;
+	long m9l1, m9l2, m9l3, m9l4, m9l5;
+	short m9s1, m9s2, m9s3, m9s4;
+	uint8_t padding[12];
+} mess_9;
+_ASSERT_MSG_SIZE(mess_9);
+
+typedef struct {
+	u64_t m10ull1;
+	int m10i1, m10i2, m10i3, m10i4;
+	long m10l1, m10l2, m10l3;
+	uint8_t padding[20];
+} mess_10;
+_ASSERT_MSG_SIZE(mess_10);
+
+/* Helper union for DS messages */
+union	ds_val {
+	cp_grant_id_t	grant;
+	u32_t		u32;
+	endpoint_t	ep;
+};
+
+typedef struct {
+	union	ds_val 	val_out;
+	int	val_len;
+	uint8_t padding[48];
+} mess_ds_reply;
+_ASSERT_MSG_SIZE(mess_ds_reply);
+
+typedef struct {
+	cp_grant_id_t	key_grant;
+	int		key_len;
+	int		flags;
+	union ds_val 	val_in;
+	int		val_len;
+	endpoint_t	owner;
+	uint8_t padding[32];
+} mess_ds_req;
+_ASSERT_MSG_SIZE(mess_ds_req);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_breadwrite;
+_ASSERT_MSG_SIZE(mess_fs_vfs_breadwrite);
+
+typedef struct {
+	mode_t mode;
+
+	uint8_t data[52];
+} mess_fs_vfs_chmod;
+_ASSERT_MSG_SIZE(mess_fs_vfs_chmod);
+
+typedef struct {
+	mode_t mode;
+
+	uint8_t data[52];
+} mess_fs_vfs_chown;
+_ASSERT_MSG_SIZE(mess_fs_vfs_chown);
+
+typedef struct {
+	off_t file_size;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[28];
+} mess_fs_vfs_create;
+_ASSERT_MSG_SIZE(mess_fs_vfs_create);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_getdents;
+_ASSERT_MSG_SIZE(mess_fs_vfs_getdents);
+
+typedef struct {
+	off_t offset;
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint16_t symloop;
+
+	uint8_t data[10];
+} mess_fs_vfs_lookup;
+_ASSERT_MSG_SIZE(mess_fs_vfs_lookup);
+
+typedef struct {
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[20];
+} mess_fs_vfs_newnode;
+_ASSERT_MSG_SIZE(mess_fs_vfs_newnode);
+
+typedef struct {
+	size_t nbytes;
+
+	uint8_t data[52];
+} mess_fs_vfs_rdlink;
+_ASSERT_MSG_SIZE(mess_fs_vfs_rdlink);
+
+typedef struct {
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	uint32_t flags;
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint16_t con_reqs;
+
+	uint8_t data[14];
+} mess_fs_vfs_readsuper;
+_ASSERT_MSG_SIZE(mess_fs_vfs_readsuper);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_readwrite;
+_ASSERT_MSG_SIZE(mess_fs_vfs_readwrite);
+
+typedef struct {
+	uint8_t padding[56];
+} mess_i2c_li2cdriver_busc_i2c_exec;
+_ASSERT_MSG_SIZE(mess_i2c_li2cdriver_busc_i2c_exec);
+
+typedef struct {
+	uint8_t padding[56];
+} mess_i2c_li2cdriver_busc_i2c_reserve;
+_ASSERT_MSG_SIZE(mess_i2c_li2cdriver_busc_i2c_reserve);
+
+typedef struct {
+	int kbd_id;
+	int mouse_id;
+	int rsvd1_id;
+	int rsvd2_id;
+
+	uint8_t padding[40];
+} mess_input_linputdriver_input_conf;
+_ASSERT_MSG_SIZE(mess_input_linputdriver_input_conf);
+
+typedef struct {
+	uint32_t led_mask;
+
+	uint8_t padding[52];
+} mess_input_linputdriver_setleds;
+_ASSERT_MSG_SIZE(mess_input_linputdriver_setleds);
+
+typedef struct {
+	int id;
+	int page;
+	int code;
+	int value;
+	int flags;
+
+	uint8_t padding[36];
+} mess_input_tty_event;
+_ASSERT_MSG_SIZE(mess_input_tty_event);
+
+typedef struct {
+	time_t acnt_queue;
+
+	unsigned long acnt_deqs;
+	unsigned long acnt_ipc_sync;
+	unsigned long acnt_ipc_async;
+	unsigned long acnt_preempt;
+	uint32_t acnt_cpu;
+	uint32_t acnt_cpu_load;
+
+	uint8_t padding[24];
+} mess_krn_lsys_schedule;
+_ASSERT_MSG_SIZE(mess_krn_lsys_schedule);
+
+typedef struct {
+	uint32_t value;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_devio;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_devio);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes msgaddr;
+
+	uint8_t padding[48];
+} mess_krn_lsys_sys_fork;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_fork);
+
+typedef struct {
+	endpoint_t endpt;
+	int privflags;
+	char name[48];
+
+} mess_krn_lsys_sys_getwhoami;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_getwhoami);
+
+typedef struct {
+	int hook_id;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_irqctl;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_irqctl);
+
+typedef struct {
+	clock_t real_ticks;
+	clock_t boot_ticks;
+	clock_t boot_time;
+	clock_t user_time;
+	clock_t system_time;
+
+	uint8_t padding[36];
+} mess_krn_lsys_sys_times;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_times);
+
+typedef struct {
+	long int data;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_trace;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_trace);
+
+typedef struct {
+	phys_bytes dst_addr;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_umap;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_umap);
+
+typedef struct {
+	int pcount;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_vumap;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_vumap);
+
+typedef struct {
+	off_t pos;
+
+	int minor;
+	int id;
+	int access;
+
+	int count;
+	cp_grant_id_t grant;
+	int flags;
+
+	endpoint_t user;
+	int request;
+
+	uint8_t padding[16];
+} mess_lbdev_lblockdriver_msg;
+_ASSERT_MSG_SIZE(mess_lbdev_lblockdriver_msg);
+
+typedef struct {
+	int status;
+	int id;
+
+	uint8_t padding[48];
+} mess_lblockdriver_lbdev_reply;
+_ASSERT_MSG_SIZE(mess_lblockdriver_lbdev_reply);
+
+typedef struct {
+	int		id;
+	int		num;
+	int		cmd;
+	int		opt;
+	int		ret;
+	uint8_t		padding[36];
+} mess_lc_ipc_semctl;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semctl);
+
+typedef struct {
+	key_t		key;
+	int		nr;
+	int		flag;
+	int		retid;
+	uint8_t		padding[40];
+} mess_lc_ipc_semget;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semget);
+
+typedef struct {
+	int		id;
+	void		*ops;
+	unsigned int	size;
+	uint8_t		padding[42];
+} mess_lc_ipc_semop;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semop);
+
+typedef struct {
+	int		id;
+	const void	*addr;
+	int		flag;
+	void		*retaddr;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmat;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmat);
+
+typedef struct {
+	int		id;
+	int		cmd;
+	void		*buf;
+	int		ret;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmctl;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmctl);
+
+typedef struct {
+	const void	*addr;
+	uint8_t		padding[52];
+} mess_lc_ipc_shmdt;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmdt);
+
+typedef struct {
+	key_t		key;
+	size_t		size;
+	int		flag;
+	int		retid;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmget;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmget);
+
+typedef struct {
+	int action;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[40];
+} mess_lc_pm_cprof;
+_ASSERT_MSG_SIZE(mess_lc_pm_cprof);
+
+typedef struct {
+	vir_bytes name;
+	size_t namelen;
+	vir_bytes frame;
+	size_t framelen;
+	vir_bytes ps_str;
+
+	uint8_t padding[36];
+} mess_lc_pm_exec;
+_ASSERT_MSG_SIZE(mess_lc_pm_exec);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_lc_pm_exit;
+_ASSERT_MSG_SIZE(mess_lc_pm_exit);
+
+typedef struct {
+	pid_t pid;
+
+	uint8_t padding[52];
+} mess_lc_pm_getsid;
+_ASSERT_MSG_SIZE(mess_lc_pm_getsid);
+
+typedef struct {
+	int num;
+	vir_bytes ptr;		/* gid_t * */
+
+	uint8_t padding[48];
+} mess_lc_pm_groups;
+_ASSERT_MSG_SIZE(mess_lc_pm_groups);
+
+typedef struct {
+	int which;
+	vir_bytes value;	/* const struct itimerval * */
+	vir_bytes ovalue;	/* struct itimerval * */
+
+	uint8_t padding[44];
+} mess_lc_pm_itimer;
+_ASSERT_MSG_SIZE(mess_lc_pm_itimer);
+
+typedef struct {
+	vir_bytes ctx;		/* mcontext_t * */
+
+	uint8_t padding[52];
+} mess_lc_pm_mcontext;
+_ASSERT_MSG_SIZE(mess_lc_pm_mcontext);
+
+typedef struct {
+	int which;
+	int who;
+	int prio;
+
+	uint8_t padding[44];
+} mess_lc_pm_priority;
+_ASSERT_MSG_SIZE(mess_lc_pm_priority);
+
+typedef struct {
+	pid_t pid;
+	int req;
+	vir_bytes addr;
+	long data;
+
+	uint8_t padding[40];
+} mess_lc_pm_ptrace;
+_ASSERT_MSG_SIZE(mess_lc_pm_ptrace);
+
+typedef struct {
+	int how;
+
+	uint8_t padding[52];
+} mess_lc_pm_reboot;
+_ASSERT_MSG_SIZE(mess_lc_pm_reboot);
+
+typedef struct {
+	endpoint_t who;
+	vir_bytes addr;
+
+	uint8_t padding[48];
+} mess_lc_pm_rusage;
+_ASSERT_MSG_SIZE(mess_lc_pm_rusage);
+
+typedef struct {
+	gid_t gid;
+
+	uint8_t padding[52];
+} mess_lc_pm_setgid;
+_ASSERT_MSG_SIZE(mess_lc_pm_setgid);
+
+typedef struct {
+	uid_t uid;
+
+	uint8_t padding[52];
+} mess_lc_pm_setuid;
+_ASSERT_MSG_SIZE(mess_lc_pm_setuid);
+
+typedef struct {
+	pid_t pid;
+	int nr;
+	vir_bytes act;		/* const struct sigaction * */
+	vir_bytes oact;		/* struct sigaction * */
+	vir_bytes ret;		/* int (*)(void) */
+
+	uint8_t padding[36];
+} mess_lc_pm_sig;
+_ASSERT_MSG_SIZE(mess_lc_pm_sig);
+
+typedef struct {
+	int how;
+	vir_bytes ctx;
+	sigset_t set;
+
+	uint8_t padding[32];
+} mess_lc_pm_sigset;
+_ASSERT_MSG_SIZE(mess_lc_pm_sigset);
+
+typedef struct {
+	int action;
+	int freq;
+	int intr_type;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[32];
+} mess_lc_pm_sprof;
+_ASSERT_MSG_SIZE(mess_lc_pm_sprof);
+
+typedef struct {
+	int req;
+	int field;
+	size_t len;
+	vir_bytes value;
+
+	uint8_t padding[40];
+} mess_lc_pm_sysuname;
+_ASSERT_MSG_SIZE(mess_lc_pm_sysuname);
+
+typedef struct {
+	time_t sec;
+
+	clockid_t clk_id;
+	int now;
+	long nsec;
+
+	uint8_t padding[36];
+} mess_lc_pm_time;
+_ASSERT_MSG_SIZE(mess_lc_pm_time);
+
+typedef struct {
+	pid_t pid;
+	int options;
+
+	uint8_t padding[48];
+} mess_lc_pm_waitpid;
+_ASSERT_MSG_SIZE(mess_lc_pm_waitpid);
+
+typedef struct {
+	cp_grant_id_t grant;
+	vir_bytes tm;			/* struct tm * */
+	int flags;
+
+	uint8_t padding[44];
+} mess_lc_readclock_rtcdev;
+_ASSERT_MSG_SIZE(mess_lc_readclock_rtcdev);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int fd;
+	uid_t owner;
+	gid_t group;
+
+	uint8_t padding[36];
+} mess_lc_vfs_chown;
+_ASSERT_MSG_SIZE(mess_lc_vfs_chown);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_close;
+_ASSERT_MSG_SIZE(mess_lc_vfs_close);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int flags;
+	mode_t mode;
+
+	uint8_t padding[40];
+} mess_lc_vfs_creat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_creat);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_fchdir;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fchdir);
+
+typedef struct {
+	int fd;
+	mode_t mode;
+
+	uint8_t padding[48];
+} mess_lc_vfs_fchmod;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fchmod);
+
+typedef struct {
+	int fd;
+	int cmd;
+	int arg_int;
+	vir_bytes arg_ptr;	/* struct flock * */
+
+	uint8_t padding[40];
+} mess_lc_vfs_fcntl;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fcntl);
+
+typedef struct {
+	int fd;
+	vir_bytes buf;		/* struct stat * */
+
+	uint8_t padding[48];
+} mess_lc_vfs_fstat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fstat);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_fsync;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fsync);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int pid;
+	vir_bytes buff_p;
+	size_t buff_sz;
+
+	uint8_t padding[40];
+} mess_lc_vfs_gcov;
+_ASSERT_MSG_SIZE(mess_lc_vfs_gcov);
+
+typedef struct {
+	int32_t flags;
+	size_t len;
+	vir_bytes buf;		/* struct statvfs */
+
+	uint8_t padding[44];
+} mess_lc_vfs_getvfsstat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_getvfsstat);
+
+typedef struct {
+	int fd;
+	unsigned long req;
+	vir_bytes arg;
+
+	uint8_t padding[44];
+} mess_lc_vfs_ioctl;
+_ASSERT_MSG_SIZE(mess_lc_vfs_ioctl);
+
+typedef struct {
+	vir_bytes name1;
+	vir_bytes name2;
+	size_t len1;
+	size_t len2;
+
+	uint8_t padding[40];
+} mess_lc_vfs_link;
+_ASSERT_MSG_SIZE(mess_lc_vfs_link);
+
+typedef struct {
+	off_t offset;
+
+	int fd;
+	int whence;
+
+	uint8_t padding[40];
+} mess_lc_vfs_lseek;
+_ASSERT_MSG_SIZE(mess_lc_vfs_lseek);
+
+typedef struct {
+	dev_t device;
+
+	vir_bytes name;
+	size_t len;
+	mode_t mode;
+
+	uint8_t padding[36];
+} mess_lc_vfs_mknod;
+_ASSERT_MSG_SIZE(mess_lc_vfs_mknod);
+
+typedef struct {
+	int flags;
+	size_t devlen;
+	size_t pathlen;
+	size_t typelen;
+	size_t labellen;
+	vir_bytes dev;
+	vir_bytes path;
+	vir_bytes type;
+	vir_bytes label;
+
+	uint8_t padding[20];
+} mess_lc_vfs_mount;
+_ASSERT_MSG_SIZE(mess_lc_vfs_mount);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int flags;
+	mode_t mode;
+	char buf[M_PATH_STRING_MAX];
+} mess_lc_vfs_path;
+_ASSERT_MSG_SIZE(mess_lc_vfs_path);
+
+typedef struct {
+	int fd0;
+	int fd1;
+	int flags;
+
+	uint8_t padding[44];
+} mess_lc_vfs_pipe2;
+_ASSERT_MSG_SIZE(mess_lc_vfs_pipe2);
+
+typedef struct {
+	vir_bytes name;		/* const char * */
+	size_t namelen;
+	vir_bytes buf;
+	size_t bufsize;
+
+	uint8_t padding[40];
+} mess_lc_vfs_readlink;
+_ASSERT_MSG_SIZE(mess_lc_vfs_readlink);
+
+typedef struct {
+	int fd;
+	vir_bytes buf;
+	size_t len;
+
+	uint8_t padding[44];
+} mess_lc_vfs_readwrite;
+_ASSERT_MSG_SIZE(mess_lc_vfs_readwrite);
+
+typedef struct {
+	vir_bytes addr;
+
+	uint8_t padding[52];
+} mess_lc_vfs_rusage;
+_ASSERT_MSG_SIZE(mess_lc_vfs_rusage);
+
+typedef struct {
+	uint32_t nfds;
+	fd_set *readfds;
+	fd_set *writefds;
+	fd_set *errorfds;
+	vir_bytes timeout;	/* user-provided 'struct timeval *' */
+
+	uint8_t padding[36];
+} mess_lc_vfs_select;
+_ASSERT_MSG_SIZE(mess_lc_vfs_select);
+
+typedef struct {
+	size_t len;
+	vir_bytes name;		/* const char * */
+	vir_bytes buf;		/* struct stat * */
+
+	uint8_t padding[44];
+} mess_lc_vfs_stat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_stat);
+
+typedef struct {
+	int fd;
+	int flags;
+	size_t len;
+	vir_bytes name;
+	vir_bytes buf;
+
+	uint8_t padding[36];
+} mess_lc_vfs_statvfs1;
+_ASSERT_MSG_SIZE(mess_lc_vfs_statvfs1);
+
+typedef struct {
+	off_t offset;
+
+	int fd;
+	vir_bytes name;
+	size_t len;
+
+	uint8_t padding[36];
+} mess_lc_vfs_truncate;
+_ASSERT_MSG_SIZE(mess_lc_vfs_truncate);
+
+typedef struct {
+	mode_t mask;
+
+	uint8_t padding[52];
+} mess_lc_vfs_umask;
+_ASSERT_MSG_SIZE(mess_lc_vfs_umask);
+
+typedef struct {
+	vir_bytes name;
+	size_t namelen;
+	vir_bytes label;
+	size_t labellen;
+
+	uint8_t padding[40];
+} mess_lc_vfs_umount;
+_ASSERT_MSG_SIZE(mess_lc_vfs_umount);
+
+typedef struct {
+	void		*addr;
+	uint8_t		padding[52];
+} mess_lc_vm_brk;
+_ASSERT_MSG_SIZE(mess_lc_vm_brk);
+
+typedef struct {
+	endpoint_t	endpt;
+	void		*addr;
+	void		*ret_addr;
+	uint8_t		padding[44];
+} mess_lc_vm_getphys;
+_ASSERT_MSG_SIZE(mess_lc_vm_getphys);
+
+typedef struct {
+	vir_bytes addr;
+
+	uint8_t padding[52];
+} mess_lc_vm_rusage;
+_ASSERT_MSG_SIZE(mess_lc_vm_rusage);
+
+typedef struct {
+	endpoint_t	forwhom;
+	void		*addr;
+	uint8_t		padding[48];
+} mess_lc_vm_shm_unmap;
+_ASSERT_MSG_SIZE(mess_lc_vm_shm_unmap);
+
+typedef struct {
+	int status;
+	uint32_t id;		/* should be cdev_id_t */
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_reply;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_reply);
+
+typedef struct {
+	int status;
+	int32_t minor;
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_sel1;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_sel1);
+
+typedef struct {
+	int status;
+	int32_t minor;
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_sel2;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_sel2);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ptr;		/* struct exec_info * */
+
+	uint8_t padding[48];
+} mess_lexec_pm_exec_new;
+_ASSERT_MSG_SIZE(mess_lexec_pm_exec_new);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t padding[52];
+} mess_li2cdriver_i2c_busc_i2c_exec;
+_ASSERT_MSG_SIZE(mess_li2cdriver_i2c_busc_i2c_exec);
+
+typedef struct {
+	uint16_t addr; /* FIXME: strictly speaking this is an i2c_addr_t, but
+			  to get it I would need to include
+			  sys/dev/i2c/i2c_io.h, which I am not sure is a good
+			  idea to have everywhere. */
+
+	uint8_t padding[54];
+} mess_li2cdriver_i2c_busc_i2c_reserve;
+_ASSERT_MSG_SIZE(mess_li2cdriver_i2c_busc_i2c_reserve);
+
+typedef struct {
+	int id;
+	int page;
+	int code;
+	int value;
+	int flags;
+
+	uint8_t padding[36];
+} mess_linputdriver_input_event;
+_ASSERT_MSG_SIZE(mess_linputdriver_input_event);
+
+typedef struct {
+        cp_grant_id_t gid;
+	size_t size;
+
+        uint8_t padding[48];
+} mess_lsys_fi_ctl;
+_ASSERT_MSG_SIZE(mess_lsys_fi_ctl);
+
+typedef struct {
+        int status;
+
+        uint8_t padding[52];
+} mess_lsys_fi_reply;
+_ASSERT_MSG_SIZE(mess_lsys_fi_reply);
+
+typedef struct {
+	int what;
+	vir_bytes where;
+	size_t size;
+
+	uint8_t padding[44];
+} mess_lsys_getsysinfo;
+_ASSERT_MSG_SIZE(mess_lsys_getsysinfo);
+
+typedef struct {
+	size_t size;
+	phys_bytes addr;
+	vir_bytes buf;
+
+	uint8_t padding[44];
+} mess_lsys_krn_readbios;
+_ASSERT_MSG_SIZE(mess_lsys_krn_readbios);
+
+typedef struct {
+	endpoint_t	from_to;
+	cp_grant_id_t	gid;
+	size_t		offset;
+	void		*address;
+	size_t		bytes;
+	uint8_t padding[36];
+} mess_lsys_kern_safecopy;
+_ASSERT_MSG_SIZE(mess_lsys_kern_safecopy);
+
+typedef struct {
+	uint32_t flags;
+	endpoint_t endpoint;
+	int priority;
+	int quantum;
+	int cpu;
+
+	uint8_t padding[36];
+} mess_lsys_krn_schedctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_schedctl);
+
+typedef struct {
+	endpoint_t endpoint;
+	int quantum;
+	int priority;
+	int cpu;
+
+	uint8_t padding[40];
+} mess_lsys_krn_schedule;
+_ASSERT_MSG_SIZE(mess_lsys_krn_schedule);
+
+typedef struct {
+	int how;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_abort;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_abort);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_clear;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_clear);
+
+typedef struct {
+	endpoint_t src_endpt;
+	vir_bytes src_addr;
+	endpoint_t dst_endpt;
+	vir_bytes dst_addr;
+	phys_bytes nr_bytes;
+	int flags;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_copy;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_copy);
+
+typedef struct {
+	endpoint_t endpt;
+	int action;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_cprof;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_cprof);
+
+typedef struct {
+	int request;
+	int port;
+	uint32_t value;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_devio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_devio);
+
+typedef struct {
+	int code;
+	vir_bytes buf;
+	int len;
+	endpoint_t endpt;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_diagctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_diagctl);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ip;
+	vir_bytes stack;
+	vir_bytes name;
+	vir_bytes ps_str;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_exec;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_exec);
+
+typedef struct {
+	endpoint_t endpt;
+	endpoint_t slot;
+	uint32_t flags;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_fork;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_fork);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes val_ptr;
+	int val_len;
+	vir_bytes val_ptr2;
+	int val_len2_e;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_getinfo;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_getinfo);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ctx_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_getmcontext;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_getmcontext);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_iopenable;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_iopenable);
+
+typedef struct {
+	int request;
+	int vector;
+	int policy;
+	int hook_id;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_irqctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_irqctl);
+
+typedef struct {
+	phys_bytes base;
+	phys_bytes count;
+	unsigned long pattern;
+	endpoint_t process;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_memset;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_memset);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes arg_ptr;
+	phys_bytes phys_start;
+	phys_bytes phys_len;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_privctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_privctl);
+
+typedef struct {
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_profbuf;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_profbuf);
+
+typedef struct {
+	int request;
+	long int port;
+	endpoint_t vec_endpt;
+	phys_bytes vec_addr;
+	vir_bytes vec_size;
+	vir_bytes offset;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_sdevio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_sdevio);
+
+typedef struct {
+	clock_t exp_time;
+	clock_t time_left;
+	int abs_time;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_setalarm;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setalarm);
+
+typedef struct {
+	vir_bytes addr;			/* cp_grant_t * */
+	int size;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_setgrant;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setgrant);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ctx_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_setmcontext;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setmcontext);
+
+typedef struct {
+	time_t sec;		/* time in seconds since 1970 */
+	long int nsec;
+	int now;		/* non-zero for immediate, 0 for adjtime */
+	clockid_t clock_id;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_settime;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_settime);
+
+typedef struct {
+	int action;
+	int freq;
+	int intr_type;
+	endpoint_t endpt;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[28];
+} mess_lsys_krn_sys_sprof;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_sprof);
+
+typedef struct {
+	int request;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_statectl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_statectl);
+
+typedef struct {
+	time_t boot_time;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_stime;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_stime);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_times;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_times);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes address;
+	long int data;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_trace;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_trace);
+
+typedef struct {
+	endpoint_t src_endpt;
+	int segment;
+	vir_bytes src_addr;
+	endpoint_t dst_endpt;
+	int nr_bytes;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_umap;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_umap);
+
+
+typedef struct {
+	int request;
+	int vec_size;
+	vir_bytes vec_addr;		/* pv{b,w,l}_pair_t * */
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_vdevio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_vdevio);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes vaddr;			/* struct vumap_vir * */
+	int vcount;
+	vir_bytes paddr;			/* struct vumap_phys * */
+	int pmax;
+	int access;
+	size_t offset;
+
+	uint8_t padding[28];
+} mess_lsys_krn_sys_vumap;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_vumap);
+
+typedef struct {
+	void		*vec_addr;
+	int		vec_size;
+	uint8_t padding[48];
+} mess_lsys_kern_vsafecopy;
+_ASSERT_MSG_SIZE(mess_lsys_kern_vsafecopy);
+
+typedef struct {
+	int devind;
+	int port;
+
+	uint8_t padding[48];
+} mess_lsys_pci_busc_get_bar;
+_ASSERT_MSG_SIZE(mess_lsys_pci_busc_get_bar);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_pm_getepinfo;
+_ASSERT_MSG_SIZE(mess_lsys_pm_getepinfo);
+
+typedef struct {
+	pid_t pid;
+
+	uint8_t padding[52];
+} mess_lsys_pm_getprocnr;
+_ASSERT_MSG_SIZE(mess_lsys_pm_getprocnr);
+
+typedef struct {
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t padding[48];
+} mess_lsys_pm_srv_fork;
+_ASSERT_MSG_SIZE(mess_lsys_pm_srv_fork);
+
+typedef struct {
+	endpoint_t endpoint;
+	endpoint_t parent;
+	int maxprio;
+	int quantum;
+
+	uint8_t padding[40];
+} mess_lsys_sched_scheduling_start;
+_ASSERT_MSG_SIZE(mess_lsys_sched_scheduling_start);
+
+typedef struct {
+	endpoint_t endpoint;
+
+	uint8_t padding[52];
+} mess_lsys_sched_scheduling_stop;
+_ASSERT_MSG_SIZE(mess_lsys_sched_scheduling_stop);
+
+typedef struct {
+	int request;
+	vir_bytes arg;
+
+	uint8_t padding[48];
+} mess_lsys_svrctl;
+_ASSERT_MSG_SIZE(mess_lsys_svrctl);
+
+typedef struct {
+	int request;
+	int fkeys;
+	int sfkeys;
+
+	uint8_t padding[44];
+} mess_lsys_tty_fkey_ctl;
+_ASSERT_MSG_SIZE(mess_lsys_tty_fkey_ctl);
+
+typedef struct {
+	endpoint_t endpt;
+	cp_grant_id_t grant;
+	size_t count;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_checkperms;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_checkperms);
+
+typedef struct {
+	endpoint_t endpt;
+	int fd;
+	int what;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_copyfd;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_copyfd);
+
+typedef struct {
+	devmajor_t major;
+	size_t labellen;
+	vir_bytes label;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_mapdriver;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_mapdriver);
+
+typedef struct {
+	endpoint_t	endpt;
+	void		*addr;
+	int		retc;
+	uint8_t		padding[44];
+} mess_lsys_vm_getref;
+_ASSERT_MSG_SIZE(mess_lsys_vm_getref);
+
+typedef struct {
+	int		what;
+	endpoint_t	ep;
+	int		count;
+	void		*ptr;
+	vir_bytes	next;
+	uint8_t		padding[36];
+} mess_lsys_vm_info;
+_ASSERT_MSG_SIZE(mess_lsys_vm_info);
+
+typedef struct {
+	endpoint_t	ep;
+	phys_bytes	phaddr;
+	size_t		len;
+	void		*reply;
+	uint8_t		padding[40];
+} mess_lsys_vm_map_phys;
+_ASSERT_MSG_SIZE(mess_lsys_vm_map_phys);
+
+typedef struct {
+	endpoint_t	ret_pt;
+	int		is_more;
+	uint8_t		padding[48];
+} mess_lsys_vm_query_exit;
+_ASSERT_MSG_SIZE(mess_lsys_vm_query_exit);
+
+typedef struct {
+	endpoint_t	ep;
+	void		*vaddr;
+	uint8_t		padding[48];
+} mess_lsys_vm_unmap_phys;
+_ASSERT_MSG_SIZE(mess_lsys_vm_unmap_phys);
+
+typedef struct {
+	endpoint_t src;
+	endpoint_t dst;
+	uint8_t		padding[48];
+} mess_lsys_vm_update;
+_ASSERT_MSG_SIZE(mess_lsys_vm_update);
+
+typedef struct {
+	endpoint_t	destination;
+	endpoint_t	source;
+	void		*dest_addr;
+	void		*src_addr;
+	size_t		size;
+	void		*ret_addr;
+	uint8_t		padding[32];
+} mess_lsys_vm_vmremap;
+_ASSERT_MSG_SIZE(mess_lsys_vm_vmremap);
+
+typedef struct {
+	endpoint_t	ep;
+	uint8_t		padding[52];
+} mess_lsys_vm_watch_exit;
+_ASSERT_MSG_SIZE(mess_lsys_vm_watch_exit);
+
+typedef struct {
+	off_t offset;
+	void *addr;
+	size_t len;
+	int prot;
+	int flags;
+	int fd;
+	endpoint_t forwhom;
+	void *retaddr;
+	u32_t padding[5];
+} mess_mmap;
+_ASSERT_MSG_SIZE(mess_mmap);
+
+typedef struct {
+	int mode;
+
+	uint8_t padding[52];
+} mess_net_netdrv_dl_conf;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_conf);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t padding[52];
+} mess_net_netdrv_dl_getstat_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_getstat_s);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int count;
+
+	uint8_t padding[48];
+} mess_net_netdrv_dl_readv_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_readv_s);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int count;
+
+	uint8_t padding[48];
+} mess_net_netdrv_dl_writev_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_writev_s);
+
+typedef struct {
+	int stat;
+	uint8_t hw_addr[6];
+
+	uint8_t padding[46];
+} mess_netdrv_net_dl_conf;
+_ASSERT_MSG_SIZE(mess_netdrv_net_dl_conf);
+
+typedef struct {
+	int count;
+	uint32_t flags;
+
+	uint8_t padding[48];
+} mess_netdrv_net_dl_task;
+_ASSERT_MSG_SIZE(mess_netdrv_net_dl_task);
+
+typedef struct {
+	u64_t timestamp;	/* valid for every notify msg */
+	u64_t interrupts;	/* raised interrupts; valid if from HARDWARE */
+	sigset_t sigset;	/* raised signals; valid if from SYSTEM */
+	uint8_t padding[24];
+} mess_notify;
+_ASSERT_MSG_SIZE(mess_notify);
+
+typedef struct {
+	int base;
+	size_t size;
+	uint32_t flags;
+
+	uint8_t padding[44];
+} mess_pci_lsys_busc_get_bar;
+_ASSERT_MSG_SIZE(mess_pci_lsys_busc_get_bar);
+
+typedef struct {
+	uid_t egid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getgid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getgid);
+
+typedef struct {
+	pid_t parent_pid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getpid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getpid);
+
+typedef struct {
+	uid_t euid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getuid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getuid);
+
+typedef struct {
+	long data;
+
+	uint8_t padding[52];
+} mess_pm_lc_ptrace;
+_ASSERT_MSG_SIZE(mess_pm_lc_ptrace);
+
+typedef struct {
+	sigset_t set;
+
+	uint8_t padding[40];
+} mess_pm_lc_sigset;
+_ASSERT_MSG_SIZE(mess_pm_lc_sigset);
+
+typedef struct {
+	time_t sec;
+
+	long nsec;
+
+	uint8_t padding[44];
+} mess_pm_lc_time;
+_ASSERT_MSG_SIZE(mess_pm_lc_time);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_pm_lc_waitpid;
+_ASSERT_MSG_SIZE(mess_pm_lc_waitpid);
+
+typedef struct {
+	int suid;
+
+	uint8_t padding[52];
+} mess_pm_lexec_exec_new;
+_ASSERT_MSG_SIZE(mess_pm_lexec_exec_new);
+
+typedef struct {
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t padding[48];
+} mess_pm_lsys_getepinfo;
+_ASSERT_MSG_SIZE(mess_pm_lsys_getepinfo);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_pm_lsys_getprocnr;
+_ASSERT_MSG_SIZE(mess_pm_lsys_getprocnr);
+
+typedef struct {
+	int num;
+
+	uint8_t padding[52];
+} mess_pm_lsys_sigs_signal;
+_ASSERT_MSG_SIZE(mess_pm_lsys_sigs_signal);
+
+typedef struct {
+	endpoint_t endpoint;
+	uint32_t maxprio;
+
+	uint8_t padding[48];
+} mess_pm_sched_scheduling_set_nice;
+_ASSERT_MSG_SIZE(mess_pm_sched_scheduling_set_nice);
+
+typedef struct {
+	pid_t recipient;	/* transfer beneficiary */
+	int amount;		/* money amount */
+
+	uint8_t padding[48];
+} mess_pm_transfermoney;
+_ASSERT_MSG_SIZE(mess_pm_transfermoney);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_readclock_lc_rtcdev;
+_ASSERT_MSG_SIZE(mess_readclock_lc_rtcdev);
+
+typedef struct {
+	int		result;
+	int		type;
+	cp_grant_id_t	rproctab_gid;
+	endpoint_t	old_endpoint;
+	uint8_t padding[40];
+} mess_rs_init;
+_ASSERT_MSG_SIZE(mess_rs_init);
+
+typedef struct {
+	endpoint_t endpt;
+	int result;
+	vir_bytes pc;
+	vir_bytes ps_str;
+
+	uint8_t padding[40];
+} mess_rs_pm_exec_restart;
+_ASSERT_MSG_SIZE(mess_rs_pm_exec_restart);
+
+typedef struct {
+	pid_t pid;
+	int nr;
+
+	uint8_t padding[48];
+} mess_rs_pm_srv_kill;
+_ASSERT_MSG_SIZE(mess_rs_pm_srv_kill);
+
+typedef struct {
+	int		len;
+	int		name_len;
+	endpoint_t	endpoint;
+	void		*addr;
+	const char	*name;
+	uint8_t padding[36];
+} mess_rs_req;
+_ASSERT_MSG_SIZE(mess_rs_req);
+
+typedef struct {
+	int		result;
+	int		state;
+	int		prepare_maxtime;
+	uint8_t padding[44];
+} mess_rs_update;
+_ASSERT_MSG_SIZE(mess_rs_update);
+
+typedef struct {
+	endpoint_t scheduler;
+
+	uint8_t padding[52];
+} mess_sched_lsys_scheduling_start;
+_ASSERT_MSG_SIZE(mess_sched_lsys_scheduling_start);
+
+/* For SYS_GETKSIG, _ENDKSIG, _KILL, _SIGSEND, _SIGRETURN. */
+typedef struct {
+	sigset_t map;		/* used to pass signal bit map */
+	endpoint_t endpt;	/* process number for inform */
+	int sig;		/* signal number to send */
+	void *sigctx;		/* pointer to signal context */
+	uint8_t padding[28];
+} mess_sigcalls;
+_ASSERT_MSG_SIZE(mess_sigcalls);
+
+typedef struct {
+	int fkeys;
+	int sfkeys;
+
+	uint8_t padding[48];
+} mess_tty_lsys_fkey_ctl;
+_ASSERT_MSG_SIZE(mess_tty_lsys_fkey_ctl);
+
+typedef struct {
+	dev_t device;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t nbytes;
+
+	uint8_t data[32];
+} mess_vfs_fs_breadwrite;
+_ASSERT_MSG_SIZE(mess_vfs_fs_breadwrite);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+
+	uint8_t data[44];
+} mess_vfs_fs_chmod;
+_ASSERT_MSG_SIZE(mess_vfs_fs_chmod);
+
+typedef struct {
+	ino_t inode;
+
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[40];
+} mess_vfs_fs_chown;
+_ASSERT_MSG_SIZE(mess_vfs_fs_chown);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[28];
+} mess_vfs_fs_create;
+_ASSERT_MSG_SIZE(mess_vfs_fs_create);
+
+typedef struct {
+	dev_t device;
+
+	uint8_t data[48];
+} mess_vfs_fs_flush;
+_ASSERT_MSG_SIZE(mess_vfs_fs_flush);
+
+typedef struct {
+	ino_t inode;
+	off_t trc_start;
+	off_t trc_end;
+
+	uint8_t data[32];
+} mess_vfs_fs_ftrunc;
+_ASSERT_MSG_SIZE(mess_vfs_fs_ftrunc);
+
+typedef struct {
+	ino_t inode;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t mem_size;
+
+	uint8_t data[32];
+} mess_vfs_fs_getdents;
+_ASSERT_MSG_SIZE(mess_vfs_fs_getdents);
+
+typedef struct {
+	ino_t inode;
+
+	uint8_t data[48];
+} mess_vfs_fs_inhibread;
+_ASSERT_MSG_SIZE(mess_vfs_fs_inhibread);
+
+typedef struct {
+	ino_t inode;
+	ino_t dir_ino;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[32];
+} mess_vfs_fs_link;
+_ASSERT_MSG_SIZE(mess_vfs_fs_link);
+
+typedef struct {
+	ino_t dir_ino;
+	ino_t root_ino;
+
+	uint32_t flags;
+	size_t path_len;
+	size_t path_size;
+	size_t ucred_size;
+	cp_grant_id_t grant_path;
+	cp_grant_id_t grant_ucred;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[8];
+} mess_vfs_fs_lookup;
+_ASSERT_MSG_SIZE(mess_vfs_fs_lookup);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[28];
+} mess_vfs_fs_mkdir;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mkdir);
+
+typedef struct {
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[20];
+} mess_vfs_fs_mknod;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mknod);
+
+typedef struct {
+	ino_t inode;
+
+	uint8_t data[48];
+} mess_vfs_fs_mountpoint;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mountpoint);
+
+typedef struct {
+	dev_t device;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[40];
+} mess_vfs_fs_new_driver;
+_ASSERT_MSG_SIZE(mess_vfs_fs_new_driver);
+
+typedef struct {
+	dev_t device;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[36];
+} mess_vfs_fs_newnode;
+_ASSERT_MSG_SIZE(mess_vfs_fs_newnode);
+
+typedef struct {
+	uint64_t count;
+	ino_t inode;
+
+	uint8_t data[40];
+} mess_vfs_fs_putnode;
+_ASSERT_MSG_SIZE(mess_vfs_fs_putnode);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+	size_t mem_size;
+
+	uint8_t data[40];
+} mess_vfs_fs_rdlink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_rdlink);
+
+typedef struct {
+	dev_t device;
+
+	uint32_t flags;
+	size_t path_len;
+	cp_grant_id_t grant;
+
+	uint8_t data[36];
+} mess_vfs_fs_readsuper;
+_ASSERT_MSG_SIZE(mess_vfs_fs_readsuper);
+
+typedef struct {
+	ino_t inode;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t nbytes;
+
+	uint8_t data[32];
+} mess_vfs_fs_readwrite;
+_ASSERT_MSG_SIZE(mess_vfs_fs_readwrite);
+
+typedef struct {
+	ino_t dir_old;
+	ino_t dir_new;
+
+	size_t len_old;
+	size_t len_new;
+	cp_grant_id_t grant_old;
+	cp_grant_id_t grant_new;
+
+	uint8_t data[24];
+} mess_vfs_fs_rename;
+_ASSERT_MSG_SIZE(mess_vfs_fs_rename);
+
+typedef struct {
+	ino_t inode;
+
+	size_t path_len;
+	size_t mem_size;
+	cp_grant_id_t grant_path;
+	cp_grant_id_t grant_target;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[24];
+} mess_vfs_fs_slink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_slink);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+
+	uint8_t data[44];
+} mess_vfs_fs_stat;
+_ASSERT_MSG_SIZE(mess_vfs_fs_stat);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t data[52];
+} mess_vfs_fs_statvfs;
+_ASSERT_MSG_SIZE(mess_vfs_fs_statvfs);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[40];
+} mess_vfs_fs_unlink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_unlink);
+
+typedef struct {
+	ino_t inode;
+	time_t actime;
+	time_t modtime;
+
+	uint32_t acnsec;
+	uint32_t modnsec;
+
+	uint8_t data[24];
+} mess_vfs_fs_utime;
+_ASSERT_MSG_SIZE(mess_vfs_fs_utime);
+
+typedef struct {
+	off_t offset;
+
+	uint8_t padding[48];
+} mess_vfs_lc_lseek;
+_ASSERT_MSG_SIZE(mess_vfs_lc_lseek);
+
+typedef struct {
+	endpoint_t id;
+	devminor_t minor;
+
+	uint8_t padding[48];
+} mess_vfs_lchardriver_cancel;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_cancel);
+
+typedef struct {
+	endpoint_t id;
+	endpoint_t user;
+	devminor_t minor;
+	int access;
+
+	uint8_t padding[40];
+} mess_vfs_lchardriver_openclose;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_openclose);
+
+typedef struct {
+	off_t pos;
+	cp_grant_id_t grant;
+	size_t count;
+	int request;
+	int flags;
+	endpoint_t id;
+	endpoint_t user;
+	devminor_t minor;
+
+	uint8_t padding[20];
+} mess_vfs_lchardriver_readwrite;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_readwrite);
+
+typedef struct {
+	devminor_t minor;
+	int ops;
+
+	uint8_t padding[48];
+} mess_vfs_lchardriver_select;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_select);
+
+typedef struct {
+	time_t atime;
+	time_t mtime;
+	long ansec;
+	long mnsec;
+	size_t len;
+	char *name;
+	int fd;
+	int flags;
+	uint8_t padding[16];
+} mess_vfs_utimens;
+_ASSERT_MSG_SIZE(mess_vfs_utimens);
+
+typedef struct {
+	off_t offset;
+	dev_t dev;
+	ino_t ino;
+	endpoint_t who;
+	u32_t vaddr;
+	u32_t len;
+	u32_t flags;
+	u32_t fd;
+	u16_t clearend;
+	uint8_t padding[8];
+} mess_vm_vfs_mmap;
+_ASSERT_MSG_SIZE(mess_vm_vfs_mmap);
+
+typedef struct {
+	dev_t dev;	/* 64bits long. */
+	off_t dev_offset;
+	off_t ino_offset;
+	ino_t ino;
+	void *block;
+	u32_t *flags_ptr;
+	u8_t pages;
+	u8_t flags;
+	uint8_t padding[12];
+} mess_vmmcp;
+_ASSERT_MSG_SIZE(mess_vmmcp);
+
+typedef struct {
+	void *addr;
+	u8_t flags;
+	uint8_t padding[51];
+} mess_vmmcp_reply;
+_ASSERT_MSG_SIZE(mess_vmmcp_reply);
+
+typedef struct {
+	endpoint_t m_source;		/* who sent the message */
+	int m_type;			/* what kind of message is it */
+	union {
+		mess_u8			m_u8;
+		mess_u16		m_u16;
+		mess_u32		m_u32;
+		mess_u64		m_u64;
+
+		mess_1			m_m1;
+		mess_2			m_m2;
+		mess_3			m_m3;
+		mess_4			m_m4;
+		mess_7			m_m7;
+		mess_9			m_m9;
+		mess_10			m_m10;
+
+		mess_ds_reply		m_ds_reply;
+		mess_ds_req		m_ds_req;
+		mess_fs_vfs_breadwrite	m_fs_vfs_breadwrite;
+		mess_fs_vfs_chmod	m_fs_vfs_chmod;
+		mess_fs_vfs_chown	m_fs_vfs_chown;
+		mess_fs_vfs_create	m_fs_vfs_create;
+		mess_fs_vfs_getdents	m_fs_vfs_getdents;
+		mess_fs_vfs_lookup	m_fs_vfs_lookup;
+		mess_fs_vfs_newnode	m_fs_vfs_newnode;
+		mess_fs_vfs_rdlink	m_fs_vfs_rdlink;
+		mess_fs_vfs_readsuper	m_fs_vfs_readsuper;
+		mess_fs_vfs_readwrite	m_fs_vfs_readwrite;
+		mess_i2c_li2cdriver_busc_i2c_exec m_i2c_li2cdriver_busc_i2c_exec;
+		mess_i2c_li2cdriver_busc_i2c_reserve m_i2c_li2cdriver_busc_i2c_reserve;
+		mess_input_linputdriver_input_conf m_input_linputdriver_input_conf;
+		mess_input_linputdriver_setleds m_input_linputdriver_setleds;
+		mess_input_tty_event	m_input_tty_event;
+		mess_krn_lsys_schedule	m_krn_lsys_schedule;
+		mess_krn_lsys_sys_devio m_krn_lsys_sys_devio;
+		mess_krn_lsys_sys_fork m_krn_lsys_sys_fork;
+		mess_krn_lsys_sys_getwhoami m_krn_lsys_sys_getwhoami;
+		mess_krn_lsys_sys_irqctl m_krn_lsys_sys_irqctl;
+		mess_krn_lsys_sys_times	m_krn_lsys_sys_times;
+		mess_krn_lsys_sys_trace	m_krn_lsys_sys_trace;
+		mess_krn_lsys_sys_umap	m_krn_lsys_sys_umap;
+		mess_krn_lsys_sys_vumap	m_krn_lsys_sys_vumap;
+		mess_lbdev_lblockdriver_msg m_lbdev_lblockdriver_msg;
+		mess_lblockdriver_lbdev_reply m_lblockdriver_lbdev_reply;
+		mess_lc_ipc_semctl	m_lc_ipc_semctl;
+		mess_lc_ipc_semget	m_lc_ipc_semget;
+		mess_lc_ipc_semop	m_lc_ipc_semop;
+		mess_lc_ipc_shmat	m_lc_ipc_shmat;
+		mess_lc_ipc_shmctl	m_lc_ipc_shmctl;
+		mess_lc_ipc_shmdt	m_lc_ipc_shmdt;
+		mess_lc_ipc_shmget	m_lc_ipc_shmget;
+		mess_lc_pm_cprof	m_lc_pm_cprof;
+		mess_lc_pm_exec		m_lc_pm_exec;
+		mess_lc_pm_exit		m_lc_pm_exit;
+		mess_lc_pm_getsid	m_lc_pm_getsid;
+		mess_lc_pm_groups	m_lc_pm_groups;
+		mess_lc_pm_itimer	m_lc_pm_itimer;
+		mess_lc_pm_mcontext	m_lc_pm_mcontext;
+		mess_lc_pm_priority	m_lc_pm_priority;
+		mess_lc_pm_ptrace	m_lc_pm_ptrace;
+		mess_lc_pm_reboot	m_lc_pm_reboot;
+		mess_lc_pm_rusage	m_lc_pm_rusage;
+		mess_lc_pm_setgid	m_lc_pm_setgid;
+		mess_lc_pm_setuid	m_lc_pm_setuid;
+		mess_lc_pm_sig		m_lc_pm_sig;
+		mess_lc_pm_sigset	m_lc_pm_sigset;
+		mess_lc_pm_sprof	m_lc_pm_sprof;
+		mess_lc_pm_sysuname	m_lc_pm_sysuname;
+		mess_lc_pm_time		m_lc_pm_time;
+		mess_lc_pm_waitpid	m_lc_pm_waitpid;
+		mess_lc_readclock_rtcdev m_lc_readclock_rtcdev;
+		mess_lc_vfs_chown	m_lc_vfs_chown;
+		mess_lc_vfs_close	m_lc_vfs_close;
+		mess_lc_vfs_creat	m_lc_vfs_creat;
+		mess_lc_vfs_fchdir	m_lc_vfs_fchdir;
+		mess_lc_vfs_fchmod	m_lc_vfs_fchmod;
+		mess_lc_vfs_fcntl	m_lc_vfs_fcntl;
+		mess_lc_vfs_fstat	m_lc_vfs_fstat;
+		mess_lc_vfs_fsync	m_lc_vfs_fsync;
+		mess_lc_vfs_gcov	m_lc_vfs_gcov;
+		mess_lc_vfs_getvfsstat	m_lc_vfs_getvfsstat;
+		mess_lc_vfs_ioctl	m_lc_vfs_ioctl;
+		mess_lc_vfs_link	m_lc_vfs_link;
+		mess_lc_vfs_lseek	m_lc_vfs_lseek;
+		mess_lc_vfs_mknod	m_lc_vfs_mknod;
+		mess_lc_vfs_mount	m_lc_vfs_mount;
+		mess_lc_vfs_path	m_lc_vfs_path;
+		mess_lc_vfs_pipe2	m_lc_vfs_pipe2;
+		mess_lc_vfs_readlink	m_lc_vfs_readlink;
+		mess_lc_vfs_readwrite	m_lc_vfs_readwrite;
+		mess_lc_vfs_rusage	m_lc_vfs_rusage;
+		mess_lc_vfs_select	m_lc_vfs_select;
+		mess_lc_vfs_stat	m_lc_vfs_stat;
+		mess_lc_vfs_statvfs1	m_lc_vfs_statvfs1;
+		mess_lc_vfs_truncate	m_lc_vfs_truncate;
+		mess_lc_vfs_umask	m_lc_vfs_umask;
+		mess_lc_vfs_umount	m_lc_vfs_umount;
+		mess_lc_vm_brk		m_lc_vm_brk;
+		mess_lc_vm_getphys	m_lc_vm_getphys;
+		mess_lc_vm_rusage	m_lc_vm_rusage;
+		mess_lc_vm_shm_unmap	m_lc_vm_shm_unmap;
+		mess_lchardriver_vfs_reply m_lchardriver_vfs_reply;
+		mess_lchardriver_vfs_sel1 m_lchardriver_vfs_sel1;
+		mess_lchardriver_vfs_sel2 m_lchardriver_vfs_sel2;
+		mess_lexec_pm_exec_new	m_lexec_pm_exec_new;
+		mess_li2cdriver_i2c_busc_i2c_exec m_li2cdriver_i2c_busc_i2c_exec;
+		mess_li2cdriver_i2c_busc_i2c_reserve m_li2cdriver_i2c_busc_i2c_reserve;
+		mess_linputdriver_input_event m_linputdriver_input_event;
+		mess_lsys_fi_ctl	m_lsys_fi_ctl;
+		mess_lsys_fi_reply	m_lsys_fi_reply;
+		mess_lsys_getsysinfo	m_lsys_getsysinfo;
+		mess_lsys_krn_readbios	m_lsys_krn_readbios;
+		mess_lsys_kern_safecopy	m_lsys_kern_safecopy;
+		mess_lsys_krn_schedctl	m_lsys_krn_schedctl;
+		mess_lsys_krn_schedule	m_lsys_krn_schedule;
+		mess_lsys_krn_sys_abort m_lsys_krn_sys_abort;
+		mess_lsys_krn_sys_clear m_lsys_krn_sys_clear;
+		mess_lsys_krn_sys_copy	m_lsys_krn_sys_copy;
+		mess_lsys_krn_sys_cprof m_lsys_krn_sys_cprof;
+		mess_lsys_krn_sys_devio m_lsys_krn_sys_devio;
+		mess_lsys_krn_sys_diagctl m_lsys_krn_sys_diagctl;
+		mess_lsys_krn_sys_exec	m_lsys_krn_sys_exec;
+		mess_lsys_krn_sys_fork	m_lsys_krn_sys_fork;
+		mess_lsys_krn_sys_getinfo m_lsys_krn_sys_getinfo;
+		mess_lsys_krn_sys_getmcontext m_lsys_krn_sys_getmcontext;
+		mess_lsys_krn_sys_iopenable m_lsys_krn_sys_iopenable;
+		mess_lsys_krn_sys_irqctl m_lsys_krn_sys_irqctl;
+		mess_lsys_krn_sys_memset m_lsys_krn_sys_memset;
+		mess_lsys_krn_sys_privctl m_lsys_krn_sys_privctl;
+		mess_lsys_krn_sys_profbuf m_lsys_krn_sys_profbuf;
+		mess_lsys_krn_sys_sdevio m_lsys_krn_sys_sdevio;
+		mess_lsys_krn_sys_setalarm m_lsys_krn_sys_setalarm;
+		mess_lsys_krn_sys_setgrant m_lsys_krn_sys_setgrant;
+		mess_lsys_krn_sys_setmcontext m_lsys_krn_sys_setmcontext;
+		mess_lsys_krn_sys_settime m_lsys_krn_sys_settime;
+		mess_lsys_krn_sys_sprof m_lsys_krn_sys_sprof;
+		mess_lsys_krn_sys_statectl m_lsys_krn_sys_statectl;
+		mess_lsys_krn_sys_stime	m_lsys_krn_sys_stime;
+		mess_lsys_krn_sys_times	m_lsys_krn_sys_times;
+		mess_lsys_krn_sys_trace	m_lsys_krn_sys_trace;
+		mess_lsys_krn_sys_umap	m_lsys_krn_sys_umap;
+		mess_lsys_krn_sys_vdevio m_lsys_krn_sys_vdevio;
+		mess_lsys_krn_sys_vumap m_lsys_krn_sys_vumap;
+		mess_lsys_kern_vsafecopy m_lsys_kern_vsafecopy;
+		mess_lsys_pci_busc_get_bar m_lsys_pci_busc_get_bar;
+		mess_lsys_pm_getepinfo	m_lsys_pm_getepinfo;
+		mess_lsys_pm_getprocnr	m_lsys_pm_getprocnr;
+		mess_lsys_pm_srv_fork	m_lsys_pm_srv_fork;
+		mess_lsys_sched_scheduling_start m_lsys_sched_scheduling_start;
+		mess_lsys_sched_scheduling_stop m_lsys_sched_scheduling_stop;
+		mess_lsys_svrctl	m_lsys_svrctl;
+		mess_lsys_tty_fkey_ctl	m_lsys_tty_fkey_ctl;
+		mess_lsys_vfs_checkperms m_lsys_vfs_checkperms;
+		mess_lsys_vfs_copyfd	m_lsys_vfs_copyfd;
+		mess_lsys_vfs_mapdriver	m_lsys_vfs_mapdriver;
+		mess_lsys_vm_getref	m_lsys_vm_getref;
+		mess_lsys_vm_info	m_lsys_vm_info;
+		mess_lsys_vm_map_phys	m_lsys_vm_map_phys;
+		mess_lsys_vm_query_exit	m_lsys_vm_query_exit;
+		mess_lsys_vm_unmap_phys	m_lsys_vm_unmap_phys;
+		mess_lsys_vm_update	m_lsys_vm_update;
+		mess_lsys_vm_vmremap	m_lsys_vm_vmremap;
+		mess_lsys_vm_watch_exit	m_lsys_vm_watch_exit;
+		mess_mmap		m_mmap;
+		mess_net_netdrv_dl_conf m_net_netdrv_dl_conf;
+		mess_net_netdrv_dl_getstat_s m_net_netdrv_dl_getstat_s;
+		mess_net_netdrv_dl_readv_s m_net_netdrv_dl_readv_s;
+		mess_net_netdrv_dl_writev_s m_net_netdrv_dl_writev_s;
+		mess_netdrv_net_dl_conf m_netdrv_net_dl_conf;
+		mess_netdrv_net_dl_task m_netdrv_net_dl_task;
+		mess_notify		m_notify;
+		mess_pci_lsys_busc_get_bar m_pci_lsys_busc_get_bar;
+		mess_pm_lc_getgid	m_pm_lc_getgid;
+		mess_pm_lc_getpid	m_pm_lc_getpid;
+		mess_pm_lc_getuid	m_pm_lc_getuid;
+		mess_pm_lc_ptrace	m_pm_lc_ptrace;
+		mess_pm_lc_sigset	m_pm_lc_sigset;
+		mess_pm_lc_time		m_pm_lc_time;
+		mess_pm_lc_waitpid	m_pm_lc_waitpid;
+		mess_pm_lexec_exec_new	m_pm_lexec_exec_new;
+		mess_pm_lsys_getepinfo	m_pm_lsys_getepinfo;
+		mess_pm_lsys_getprocnr	m_pm_lsys_getprocnr;
+		mess_pm_lsys_sigs_signal m_pm_lsys_sigs_signal;
+		mess_pm_sched_scheduling_set_nice m_pm_sched_scheduling_set_nice;
+		mess_pm_transfermoney m_pm_transfermoney;
+		mess_readclock_lc_rtcdev m_readclock_lc_rtcdev;
+		mess_rs_init		m_rs_init;
+		mess_rs_pm_exec_restart	m_rs_pm_exec_restart;
+		mess_rs_pm_srv_kill	m_rs_pm_srv_kill;
+		mess_rs_req		m_rs_req;
+		mess_rs_update		m_rs_update;
+		mess_sched_lsys_scheduling_start m_sched_lsys_scheduling_start;
+		mess_sigcalls		m_sigcalls;
+		mess_tty_lsys_fkey_ctl	m_tty_lsys_fkey_ctl;
+		mess_vfs_fs_breadwrite	m_vfs_fs_breadwrite;
+		mess_vfs_fs_chmod	m_vfs_fs_chmod;
+		mess_vfs_fs_chown	m_vfs_fs_chown;
+		mess_vfs_fs_create	m_vfs_fs_create;
+		mess_vfs_fs_flush	m_vfs_fs_flush;
+		mess_vfs_fs_ftrunc	m_vfs_fs_ftrunc;
+		mess_vfs_fs_getdents	m_vfs_fs_getdents;
+		mess_vfs_fs_inhibread	m_vfs_fs_inhibread;
+		mess_vfs_fs_link	m_vfs_fs_link;
+		mess_vfs_fs_lookup	m_vfs_fs_lookup;
+		mess_vfs_fs_mkdir	m_vfs_fs_mkdir;
+		mess_vfs_fs_mknod	m_vfs_fs_mknod;
+		mess_vfs_fs_mountpoint	m_vfs_fs_mountpoint;
+		mess_vfs_fs_new_driver	m_vfs_fs_new_driver;
+		mess_vfs_fs_newnode	m_vfs_fs_newnode;
+		mess_vfs_fs_putnode	m_vfs_fs_putnode;
+		mess_vfs_fs_rdlink	m_vfs_fs_rdlink;
+		mess_vfs_fs_readsuper	m_vfs_fs_readsuper;
+		mess_vfs_fs_readwrite	m_vfs_fs_readwrite;
+		mess_vfs_fs_rename	m_vfs_fs_rename;
+		mess_vfs_fs_slink	m_vfs_fs_slink;
+		mess_vfs_fs_stat	m_vfs_fs_stat;
+		mess_vfs_fs_statvfs	m_vfs_fs_statvfs;
+		mess_vfs_fs_unlink	m_vfs_fs_unlink;
+		mess_vfs_fs_utime	m_vfs_fs_utime;
+		mess_vfs_lc_lseek	m_vfs_lc_lseek;
+		mess_vfs_lchardriver_cancel	m_vfs_lchardriver_cancel;
+		mess_vfs_lchardriver_openclose	m_vfs_lchardriver_openclose;
+		mess_vfs_lchardriver_readwrite	m_vfs_lchardriver_readwrite;
+		mess_vfs_lchardriver_select	m_vfs_lchardriver_select;
+		mess_vfs_utimens	m_vfs_utimens;
+		mess_vm_vfs_mmap	m_vm_vfs_mmap;
+		mess_vmmcp		m_vmmcp;
+		mess_vmmcp_reply	m_vmmcp_reply;
+
+		u8_t size[56];	/* message payload may have 56 bytes at most */
+	};
+} message __aligned(16);
+
+/* Ensure the complete union respects the IPC assumptions. */
+typedef int _ASSERT_message[/* CONSTCOND */sizeof(message) == 64 ? 1 : -1];
+
+/* The following defines provide names for useful members. */
+#define m1_i1  m_m1.m1i1
+#define m1_i2  m_m1.m1i2
+#define m1_i3  m_m1.m1i3
+#define m1_p1  m_m1.m1p1
+#define m1_p2  m_m1.m1p2
+#define m1_p3  m_m1.m1p3
+#define m1_p4  m_m1.m1p4
+#define m1_ull1  m_m1.m1ull1
+
+#define m2_ll1  m_m2.m2ll1
+#define m2_i1  m_m2.m2i1
+#define m2_i2  m_m2.m2i2
+#define m2_i3  m_m2.m2i3
+#define m2_l1  m_m2.m2l1
+#define m2_l2  m_m2.m2l2
+#define m2_p1  m_m2.m2p1
+#define m2_sigset  m_m2.sigset
+
+#define m2_s1  m_m2.m2s1
+
+#define m3_i1  m_m3.m3i1
+#define m3_i2  m_m3.m3i2
+#define m3_p1  m_m3.m3p1
+#define m3_ca1 m_m3.m3ca1
+
+#define m4_ll1  m_m4.m4ll1
+#define m4_l1  m_m4.m4l1
+#define m4_l2  m_m4.m4l2
+#define m4_l3  m_m4.m4l3
+#define m4_l4  m_m4.m4l4
+#define m4_l5  m_m4.m4l5
+
+#define m7_i1  m_m7.m7i1
+#define m7_i2  m_m7.m7i2
+#define m7_i3  m_m7.m7i3
+#define m7_i4  m_m7.m7i4
+#define m7_i5  m_m7.m7i5
+#define m7_p1  m_m7.m7p1
+#define m7_p2  m_m7.m7p2
+
+#define m9_l1  m_m9.m9l1
+#define m9_l2  m_m9.m9l2
+#define m9_l3  m_m9.m9l3
+#define m9_l4  m_m9.m9l4
+#define m9_l5  m_m9.m9l5
+#define m9_s1  m_m9.m9s1
+#define m9_s2  m_m9.m9s2
+#define m9_s3  m_m9.m9s3
+#define m9_s4  m_m9.m9s4
+#define m9_ull1  m_m9.m9ull1
+#define m9_ull2  m_m9.m9ull2
+
+#define m10_i1 m_m10.m10i1
+#define m10_i2 m_m10.m10i2
+#define m10_i3 m_m10.m10i3
+#define m10_i4 m_m10.m10i4
+#define m10_l1 m_m10.m10l1
+#define m10_l2 m_m10.m10l2
+#define m10_l3 m_m10.m10l3
+#define m10_ull1 m_m10.m10ull1
+
+
+/*==========================================================================* 
+ * Minix run-time system (IPC). 					    *
+ *==========================================================================*/ 
+
+/* Datastructure for asynchronous sends */
+typedef struct asynmsg
+{
+	unsigned flags;
+	endpoint_t dst;
+	int result;
+	message msg;
+} asynmsg_t;
+
+/* Defines for flags field */
+#define AMF_EMPTY	000	/* slot is not inuse */
+#define AMF_VALID	001	/* slot contains message */
+#define AMF_DONE	002	/* Kernel has processed the message. The
+				 * result is stored in 'result'
+				 */
+#define AMF_NOTIFY	004	/* Send a notification when AMF_DONE is set */
+#define AMF_NOREPLY	010	/* Not a reply message for a SENDREC */
+#define AMF_NOTIFY_ERR	020	/* Send a notification when AMF_DONE is set and
+				 * delivery of the message failed */
+
+int _ipc_send_intr(endpoint_t dest, message *m_ptr);
+int _ipc_receive_intr(endpoint_t src, message *m_ptr, int *status_ptr);
+int _ipc_sendrec_intr(endpoint_t src_dest, message *m_ptr);
+int _ipc_sendnb_intr(endpoint_t dest, message *m_ptr);
+int _ipc_notify_intr(endpoint_t dest);
+int _ipc_senda_intr(asynmsg_t *table, size_t count);
+
+int _do_kernel_call_intr(message *m_ptr);
+
+int get_minix_kerninfo(struct minix_kerninfo **);
+
+/* Hide names to avoid name space pollution. */
+#define ipc_notify	_ipc_notify
+#define ipc_sendrec	_ipc_sendrec
+#define ipc_receive	_ipc_receive
+#define ipc_receivenb	_ipc_receivenb
+#define ipc_send	_ipc_send
+#define ipc_sendnb	_ipc_sendnb
+#define ipc_senda	_ipc_senda
+
+#define do_kernel_call	_do_kernel_call
+
+struct minix_ipcvecs {
+	int (*send)(endpoint_t dest, message *m_ptr);
+	int (*receive)(endpoint_t src, message *m_ptr, int *st);
+	int (*sendrec)(endpoint_t src_dest, message *m_ptr);
+	int (*sendnb)(endpoint_t dest, message *m_ptr);
+	int (*notify)(endpoint_t dest);
+	int (*do_kernel_call)(message *m_ptr);
+	int (*senda)(asynmsg_t *table, size_t count);
+};
+
+/* kernel-set IPC vectors retrieved by a constructor in
+ * minix/lib/libc/sys/init.c */
+extern struct minix_ipcvecs _minix_ipcvecs;
+
+static inline int _ipc_send(endpoint_t dest, message *m_ptr)
+{
+	return _minix_ipcvecs.send(dest, m_ptr);
+}
+
+static inline int _ipc_receive(endpoint_t src, message *m_ptr, int *st)
+{
+	return _minix_ipcvecs.receive(src, m_ptr, st);
+}
+
+static inline int _ipc_sendrec(endpoint_t src_dest, message *m_ptr)
+{
+	return _minix_ipcvecs.sendrec(src_dest, m_ptr);
+}
+
+static inline int _ipc_sendnb(endpoint_t dest, message *m_ptr)
+{
+	return _minix_ipcvecs.sendnb(dest, m_ptr);
+}
+
+static inline int _ipc_notify(endpoint_t dest)
+{
+	return _minix_ipcvecs.notify(dest);
+}
+
+static inline int _do_kernel_call(message *m_ptr)
+{
+	return _minix_ipcvecs.do_kernel_call(m_ptr);
+}
+
+static inline int _ipc_senda(asynmsg_t *table, size_t count)
+{
+	return _minix_ipcvecs.senda(table, count);
+}
+
+#endif /* _IPC_H */
diff -rupNEZbB syf/usr/usr/src/minix/servers/pm/do_transfermoney.c syf/usr_new/usr/src/minix/servers/pm/do_transfermoney.c
--- syf/usr/usr/src/minix/servers/pm/do_transfermoney.c	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/servers/pm/do_transfermoney.c	2023-05-14 18:19:04.375707928 +0200
@@ -0,0 +1,42 @@
+#include "pm.h"
+#include "mproc.h"
+#include "proto.h"
+#include <minix/callnr.h>
+
+int CBS(struct mproc* a, struct mproc* b) 
+{
+	do {
+		if (a->mp_pid == 1)
+			return 0;
+		a = &mproc[a->mp_parent];
+	} while (a != b);
+
+	return -1;
+}
+
+int do_transfermoney(void) 
+{
+	pid_t dest_pid = m_in.m_pm_transfermoney.recipient;
+	int amount = m_in.m_pm_transfermoney.amount;
+
+	if (amount < 0)
+		return EINVAL;
+
+	struct mproc* dest_ptr = find_proc(dest_pid);
+	if (dest_ptr == NULL)
+		return ESRCH;;
+
+	if (CBS(mp, dest_ptr) == -1 || CBS(dest_ptr, mp) == -1)
+		return EPERM;
+
+	if (MAX_BALANCE - amount < dest_ptr->mp_money 
+		|| amount > mp->mp_money)
+	{
+		return EINVAL;
+	}
+
+	mp->mp_money -= amount;
+	dest_ptr->mp_money += amount;
+
+	return mp->mp_money;
+}
diff -rupNEZbB syf/usr/usr/src/minix/servers/pm/forkexit.c syf/usr_new/usr/src/minix/servers/pm/forkexit.c
--- syf/usr/usr/src/minix/servers/pm/forkexit.c	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/servers/pm/forkexit.c	2023-05-14 14:58:14.084681535 +0200
@@ -0,0 +1,733 @@
+/* This file deals with creating processes (via FORK) and deleting them (via
+ * EXIT/WAITPID).  When a process forks, a new slot in the 'mproc' table is
+ * allocated for it, and a copy of the parent's core image is made for the
+ * child.  Then the kernel and file system are informed.  A process is removed
+ * from the 'mproc' table when two events have occurred: (1) it has exited or
+ * been killed by a signal, and (2) the parent has done a WAITPID.  If the
+ * process exits first, it continues to occupy a slot until the parent does a
+ * WAITPID.
+ *
+ * The entry points into this file are:
+ *   do_fork:		perform the FORK system call
+ *   do_srv_fork:	special FORK, used by RS to create sys services
+ *   do_exit:		perform the EXIT system call (by calling exit_proc())
+ *   exit_proc:		actually do the exiting, and tell VFS about it
+ *   exit_restart:	continue exiting a process after VFS has replied
+ *   do_waitpid:	perform the WAITPID system call
+ *   wait_test:		check whether a parent is waiting for a child
+ */
+
+#include "pm.h"
+#include <sys/wait.h>
+#include <assert.h>
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <minix/sched.h>
+#include <minix/vm.h>
+#include <sys/ptrace.h>
+#include <sys/resource.h>
+#include <signal.h>
+#include "mproc.h"
+
+#define LAST_FEW            2	/* last few slots reserved for superuser */
+
+static void zombify(struct mproc *rmp);
+static void check_parent(struct mproc *child, int try_cleanup);
+static void tell_parent(struct mproc *child);
+static void tell_tracer(struct mproc *child);
+static void tracer_died(struct mproc *child);
+static void cleanup(register struct mproc *rmp);
+
+/*===========================================================================*
+ *				do_fork					     *
+ *===========================================================================*/
+int do_fork()
+{
+/* The process pointed to by 'mp' has forked.  Create a child process. */
+  register struct mproc *rmp;	/* pointer to parent */
+  register struct mproc *rmc;	/* pointer to child */
+  pid_t new_pid;
+  static unsigned int next_child = 0;
+  int i, n = 0, s;
+  endpoint_t child_ep;
+  message m;
+
+ /* If tables might fill up during FORK, don't even start since recovery half
+  * way through is such a nuisance.
+  */
+  rmp = mp;
+  if ((procs_in_use == NR_PROCS) || 
+  		(procs_in_use >= NR_PROCS-LAST_FEW && rmp->mp_effuid != 0))
+  {
+  	printf("PM: warning, process table is full!\n");
+  	return(EAGAIN);
+  }
+
+  /* Find a slot in 'mproc' for the child process.  A slot must exist. */
+  do {
+        next_child = (next_child+1) % NR_PROCS;
+	n++;
+  } while((mproc[next_child].mp_flags & IN_USE) && n <= NR_PROCS);
+  if(n > NR_PROCS)
+	panic("do_fork can't find child slot");
+  if(next_child >= NR_PROCS || (mproc[next_child].mp_flags & IN_USE))
+	panic("do_fork finds wrong child slot: %d", next_child);
+
+  /* Memory part of the forking. */
+  if((s=vm_fork(rmp->mp_endpoint, next_child, &child_ep)) != OK) {
+	return s;
+  }
+
+  /* PM may not fail fork after call to vm_fork(), as VM calls sys_fork(). */
+
+  rmc = &mproc[next_child];
+  /* Set up the child and its memory map; copy its 'mproc' slot from parent. */
+  procs_in_use++;
+  *rmc = *rmp;			/* copy parent's process slot to child's */
+  rmc->mp_parent = who_p;			/* record child's parent */
+  if (!(rmc->mp_trace_flags & TO_TRACEFORK)) {
+	rmc->mp_tracer = NO_TRACER;		/* no tracer attached */
+	rmc->mp_trace_flags = 0;
+	(void) sigemptyset(&rmc->mp_sigtrace);
+  }
+
+  /* Some system servers like to call regular fork, such as RS spawning
+   * recovery scripts; in this case PM will take care of their scheduling
+   * because RS cannot do so for non-system processes */
+  if (rmc->mp_flags & PRIV_PROC) {
+	assert(rmc->mp_scheduler == NONE);
+	rmc->mp_scheduler = SCHED_PROC_NR;
+  }
+
+  /* Inherit only these flags. In normal fork(), PRIV_PROC is not inherited. */
+  rmc->mp_flags &= (IN_USE|DELAY_CALL|TAINTED);
+  rmc->mp_child_utime = 0;		/* reset administration */
+  rmc->mp_child_stime = 0;		/* reset administration */
+  rmc->mp_exitstatus = 0;
+  rmc->mp_sigstatus = 0;
+  rmc->mp_money = INIT_BALANCE;
+  rmc->mp_endpoint = child_ep;		/* passed back by VM */
+  for (i = 0; i < NR_ITIMERS; i++)
+	rmc->mp_interval[i] = 0;	/* reset timer intervals */
+
+  /* Find a free pid for the child and put it in the table. */
+  new_pid = get_free_pid();
+  rmc->mp_pid = new_pid;	/* assign pid to child */
+
+  memset(&m, 0, sizeof(m));
+  m.m_type = VFS_PM_FORK;
+  m.VFS_PM_ENDPT = rmc->mp_endpoint;
+  m.VFS_PM_PENDPT = rmp->mp_endpoint;
+  m.VFS_PM_CPID = rmc->mp_pid;
+  m.VFS_PM_REUID = -1;	/* Not used by VFS_PM_FORK */
+  m.VFS_PM_REGID = -1;	/* Not used by VFS_PM_FORK */
+
+  tell_vfs(rmc, &m);
+
+  /* Tell the tracer, if any, about the new child */
+  if (rmc->mp_tracer != NO_TRACER)
+	sig_proc(rmc, SIGSTOP, TRUE /*trace*/, FALSE /* ksig */);
+
+  /* Do not reply until VFS is ready to process the fork
+  * request
+  */
+  return SUSPEND;
+}
+
+/*===========================================================================*
+ *				do_srv_fork				     *
+ *===========================================================================*/
+int do_srv_fork()
+{
+/* The process pointed to by 'mp' has forked.  Create a child process. */
+  register struct mproc *rmp;	/* pointer to parent */
+  register struct mproc *rmc;	/* pointer to child */
+  int s;
+  pid_t new_pid;
+  static unsigned int next_child = 0;
+  int i, n = 0;
+  endpoint_t child_ep;
+  message m;
+
+  /* Only RS is allowed to use srv_fork. */
+  if (mp->mp_endpoint != RS_PROC_NR)
+	return EPERM;
+
+ /* If tables might fill up during FORK, don't even start since recovery half
+  * way through is such a nuisance.
+  */
+  rmp = mp;
+  if ((procs_in_use == NR_PROCS) || 
+  		(procs_in_use >= NR_PROCS-LAST_FEW && rmp->mp_effuid != 0))
+  {
+  	printf("PM: warning, process table is full!\n");
+  	return(EAGAIN);
+  }
+
+  /* Find a slot in 'mproc' for the child process.  A slot must exist. */
+  do {
+        next_child = (next_child+1) % NR_PROCS;
+	n++;
+  } while((mproc[next_child].mp_flags & IN_USE) && n <= NR_PROCS);
+  if(n > NR_PROCS)
+	panic("do_fork can't find child slot");
+  if(next_child >= NR_PROCS || (mproc[next_child].mp_flags & IN_USE))
+	panic("do_fork finds wrong child slot: %d", next_child);
+
+  if((s=vm_fork(rmp->mp_endpoint, next_child, &child_ep)) != OK) {
+	return s;
+  }
+
+  rmc = &mproc[next_child];
+  /* Set up the child and its memory map; copy its 'mproc' slot from parent. */
+  procs_in_use++;
+  *rmc = *rmp;			/* copy parent's process slot to child's */
+  rmc->mp_parent = who_p;			/* record child's parent */
+  if (!(rmc->mp_trace_flags & TO_TRACEFORK)) {
+	rmc->mp_tracer = NO_TRACER;		/* no tracer attached */
+	rmc->mp_trace_flags = 0;
+	(void) sigemptyset(&rmc->mp_sigtrace);
+  }
+  /* inherit only these flags */
+  rmc->mp_flags &= (IN_USE|PRIV_PROC|DELAY_CALL);
+  rmc->mp_child_utime = 0;		/* reset administration */
+  rmc->mp_child_stime = 0;		/* reset administration */
+  rmc->mp_exitstatus = 0;
+  rmc->mp_sigstatus = 0;
+  rmc->mp_money = INIT_BALANCE;
+  rmc->mp_endpoint = child_ep;		/* passed back by VM */
+  rmc->mp_realuid = m_in.m_lsys_pm_srv_fork.uid;
+  rmc->mp_effuid = m_in.m_lsys_pm_srv_fork.uid;
+  rmc->mp_realgid = m_in.m_lsys_pm_srv_fork.gid;
+  rmc->mp_effgid = m_in.m_lsys_pm_srv_fork.gid;
+  for (i = 0; i < NR_ITIMERS; i++)
+	rmc->mp_interval[i] = 0;	/* reset timer intervals */
+
+  /* Find a free pid for the child and put it in the table. */
+  new_pid = get_free_pid();
+  rmc->mp_pid = new_pid;	/* assign pid to child */
+
+  memset(&m, 0, sizeof(m));
+  m.m_type = VFS_PM_SRV_FORK;
+  m.VFS_PM_ENDPT = rmc->mp_endpoint;
+  m.VFS_PM_PENDPT = rmp->mp_endpoint;
+  m.VFS_PM_CPID = rmc->mp_pid;
+  m.VFS_PM_REUID = m_in.m_lsys_pm_srv_fork.uid;
+  m.VFS_PM_REGID = m_in.m_lsys_pm_srv_fork.gid;
+
+  tell_vfs(rmc, &m);
+
+  /* Tell the tracer, if any, about the new child */
+  if (rmc->mp_tracer != NO_TRACER)
+	sig_proc(rmc, SIGSTOP, TRUE /*trace*/, FALSE /* ksig */);
+
+  /* Wakeup the newly created process */
+  reply(rmc-mproc, OK);
+
+  return rmc->mp_pid;
+}
+
+/*===========================================================================*
+ *				do_exit					     *
+ *===========================================================================*/
+int do_exit()
+{
+ /* Perform the exit(status) system call. The real work is done by exit_proc(),
+  * which is also called when a process is killed by a signal. System processes
+  * do not use PM's exit() to terminate. If they try to, we warn the user
+  * and send a SIGKILL signal to the system process.
+  */
+  if(mp->mp_flags & PRIV_PROC) {
+      printf("PM: system process %d (%s) tries to exit(), sending SIGKILL\n",
+          mp->mp_endpoint, mp->mp_name);
+      sys_kill(mp->mp_endpoint, SIGKILL);
+  }
+  else {
+      exit_proc(mp, m_in.m_lc_pm_exit.status, FALSE /*dump_core*/);
+  }
+  return(SUSPEND);		/* can't communicate from beyond the grave */
+}
+
+/*===========================================================================*
+ *				exit_proc				     *
+ *===========================================================================*/
+void exit_proc(rmp, exit_status, dump_core)
+register struct mproc *rmp;	/* pointer to the process to be terminated */
+int exit_status;		/* the process' exit status (for parent) */
+int dump_core;			/* flag indicating whether to dump core */
+{
+/* A process is done.  Release most of the process' possessions.  If its
+ * parent is waiting, release the rest, else keep the process slot and
+ * become a zombie.
+ */
+  register int proc_nr, proc_nr_e;
+  int r;
+  pid_t procgrp;
+  struct mproc *p_mp;
+  clock_t user_time, sys_time;
+  message m;
+
+  /* Do not create core files for set uid execution */
+  if (dump_core && rmp->mp_realuid != rmp->mp_effuid)
+	dump_core = FALSE;
+
+  /* System processes are destroyed before informing VFS, meaning that VFS can
+   * not get their CPU state, so we can't generate a coredump for them either.
+   */
+  if (dump_core && (rmp->mp_flags & PRIV_PROC))
+	dump_core = FALSE;
+
+  proc_nr = (int) (rmp - mproc);	/* get process slot number */
+  proc_nr_e = rmp->mp_endpoint;
+
+  /* Remember a session leader's process group. */
+  procgrp = (rmp->mp_pid == mp->mp_procgrp) ? mp->mp_procgrp : 0;
+
+  /* If the exited process has a timer pending, kill it. */
+  if (rmp->mp_flags & ALARM_ON) set_alarm(rmp, (clock_t) 0);
+
+  /* Do accounting: fetch usage times and accumulate at parent. */
+  if((r=sys_times(proc_nr_e, &user_time, &sys_time, NULL, NULL)) != OK)
+  	panic("exit_proc: sys_times failed: %d", r);
+
+  p_mp = &mproc[rmp->mp_parent];			/* process' parent */
+  p_mp->mp_child_utime += user_time + rmp->mp_child_utime; /* add user time */
+  p_mp->mp_child_stime += sys_time + rmp->mp_child_stime; /* add system time */
+
+  /* Tell the kernel the process is no longer runnable to prevent it from 
+   * being scheduled in between the following steps. Then tell VFS that it 
+   * the process has exited and finally, clean up the process at the kernel.
+   * This order is important so that VFS can tell drivers to cancel requests
+   * such as copying to/ from the exiting process, before it is gone.
+   */
+  /* If the process is not yet stopped, we force a stop here. This means that
+   * the process may still have a delay call pending. For this reason, the main
+   * message loop discards requests from exiting processes.
+   */
+  if (!(rmp->mp_flags & PROC_STOPPED)) {
+	if ((r = sys_stop(proc_nr_e)) != OK)		/* stop the process */
+		panic("sys_stop failed: %d", r);
+	rmp->mp_flags |= PROC_STOPPED;
+  }
+
+  if((r=vm_willexit(proc_nr_e)) != OK) {
+	panic("exit_proc: vm_willexit failed: %d", r);
+  }
+  vm_notify_sig_wrapper(rmp->mp_endpoint);
+  if (proc_nr_e == INIT_PROC_NR)
+  {
+	printf("PM: INIT died with exit status %d; showing stacktrace\n", exit_status);
+	sys_diagctl_stacktrace(proc_nr_e);
+	return;
+  }
+  if (proc_nr_e == VFS_PROC_NR)
+  {
+	panic("exit_proc: VFS died: %d", r);
+  }
+
+  /* Tell VFS about the exiting process. */
+  memset(&m, 0, sizeof(m));
+  m.m_type = dump_core ? VFS_PM_DUMPCORE : VFS_PM_EXIT;
+  m.VFS_PM_ENDPT = rmp->mp_endpoint;
+
+  if (dump_core) {
+	m.VFS_PM_TERM_SIG = rmp->mp_sigstatus;
+	m.VFS_PM_PATH = rmp->mp_name;
+  }
+
+  tell_vfs(rmp, &m);
+
+  if (rmp->mp_flags & PRIV_PROC)
+  {
+	/* Destroy system processes without waiting for VFS. This is
+	 * needed because the system process might be a block device
+	 * driver that VFS is blocked waiting on.
+	 */
+	if((r= sys_clear(rmp->mp_endpoint)) != OK)
+		panic("exit_proc: sys_clear failed: %d", r);
+  }
+
+  /* Clean up most of the flags describing the process's state before the exit,
+   * and mark it as exiting.
+   */
+  rmp->mp_flags &= (IN_USE|VFS_CALL|PRIV_PROC|TRACE_EXIT|PROC_STOPPED);
+  rmp->mp_flags |= EXITING;
+
+  /* Keep the process around until VFS is finished with it. */
+  
+  rmp->mp_exitstatus = (char) exit_status;
+
+  /* For normal exits, try to notify the parent as soon as possible.
+   * For core dumps, notify the parent only once the core dump has been made.
+   */
+  if (!dump_core)
+	zombify(rmp);
+
+  /* If the process has children, disinherit them.  INIT is the new parent. */
+  for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++) {
+	if (!(rmp->mp_flags & IN_USE)) continue;
+	if (rmp->mp_tracer == proc_nr) {
+		/* This child's tracer died. Do something sensible. */
+		tracer_died(rmp);
+	}
+	if (rmp->mp_parent == proc_nr) {
+		/* 'rmp' now points to a child to be disinherited. */
+		rmp->mp_parent = INIT_PROC_NR;
+
+		/* If the process is making a VFS call, remember that we set
+		 * a new parent. This prevents FORK from replying to the wrong
+		 * parent upon completion.
+		 */
+		if (rmp->mp_flags & VFS_CALL)
+			rmp->mp_flags |= NEW_PARENT;
+
+		/* Notify new parent. */
+		if (rmp->mp_flags & ZOMBIE)
+			check_parent(rmp, TRUE /*try_cleanup*/);
+	}
+  }
+
+  /* Send a hangup to the process' process group if it was a session leader. */
+  if (procgrp != 0) check_sig(-procgrp, SIGHUP, FALSE /* ksig */);
+}
+
+/*===========================================================================*
+ *				exit_restart				     *
+ *===========================================================================*/
+void exit_restart(rmp, dump_core)
+struct mproc *rmp;		/* pointer to the process being terminated */
+int dump_core;			/* flag indicating whether to dump core */
+{
+/* VFS replied to our exit or coredump request. Perform the second half of the
+ * exit code.
+ */
+  int r;
+
+  if((r = sched_stop(rmp->mp_scheduler, rmp->mp_endpoint)) != OK) {
+ 	/* If the scheduler refuses to give up scheduling, there is
+	 * little we can do, except report it. This may cause problems
+	 * later on, if this scheduler is asked to schedule another proc
+	 * that has an endpoint->schedproc mapping identical to the proc
+	 * we just tried to stop scheduling.
+	*/
+	printf("PM: The scheduler did not want to give up "
+		"scheduling %s, ret=%d.\n", rmp->mp_name, r);
+  } 
+
+  /* sched_stop is either called when the process is exiting or it is
+   * being moved between schedulers. If it is being moved between
+   * schedulers, we need to set the mp_scheduler to NONE so that PM
+   * doesn't forward messages to the process' scheduler while being moved
+   * (such as sched_nice). */
+  rmp->mp_scheduler = NONE;
+
+  /* For core dumps, now is the right time to try to contact the parent. */
+  if (dump_core)
+	zombify(rmp);
+
+  if (!(rmp->mp_flags & PRIV_PROC))
+  {
+	/* destroy the (user) process */
+	if((r=sys_clear(rmp->mp_endpoint)) != OK)
+		panic("exit_restart: sys_clear failed: %d", r);
+  }
+
+  /* Release the memory occupied by the child. */
+  if((r=vm_exit(rmp->mp_endpoint)) != OK) {
+  	panic("exit_restart: vm_exit failed: %d", r);
+  }
+
+  if (rmp->mp_flags & TRACE_EXIT)
+  {
+	/* Wake up the tracer, completing the ptrace(T_EXIT) call */
+	mproc[rmp->mp_tracer].mp_reply.m_pm_lc_ptrace.data = 0;
+	reply(rmp->mp_tracer, OK);
+  }
+
+  /* Clean up if the parent has collected the exit status */
+  if (rmp->mp_flags & TOLD_PARENT)
+	cleanup(rmp);
+}
+
+/*===========================================================================*
+ *				do_waitpid				     *
+ *===========================================================================*/
+int do_waitpid()
+{
+/* A process wants to wait for a child to terminate. If a child is already 
+ * waiting, go clean it up and let this WAITPID call terminate.  Otherwise,
+ * really wait. 
+ * A process calling WAITPID never gets a reply in the usual way at the end
+ * of the main loop (unless WNOHANG is set or no qualifying child exists).
+ * If a child has already exited, the routine tell_parent() sends the reply
+ * to awaken the caller.
+ */
+  register struct mproc *rp;
+  int i, pidarg, options, children;
+
+  /* Set internal variables. */
+  pidarg  = m_in.m_lc_pm_waitpid.pid;		/* 1st param */
+  options = m_in.m_lc_pm_waitpid.options;	/* 3rd param */
+  if (pidarg == 0) pidarg = -mp->mp_procgrp;	/* pidarg < 0 ==> proc grp */
+
+  /* Is there a child waiting to be collected? At this point, pidarg != 0:
+   *	pidarg  >  0 means pidarg is pid of a specific process to wait for
+   *	pidarg == -1 means wait for any child
+   *	pidarg  < -1 means wait for any child whose process group = -pidarg
+   */
+  children = 0;
+  for (rp = &mproc[0]; rp < &mproc[NR_PROCS]; rp++) {
+	if ((rp->mp_flags & (IN_USE | TOLD_PARENT)) != IN_USE) continue;
+	if (rp->mp_parent != who_p && rp->mp_tracer != who_p) continue;
+	if (rp->mp_parent != who_p && (rp->mp_flags & ZOMBIE)) continue;
+
+	/* The value of pidarg determines which children qualify. */
+	if (pidarg  > 0 && pidarg != rp->mp_pid) continue;
+	if (pidarg < -1 && -pidarg != rp->mp_procgrp) continue;
+
+	children++;			/* this child is acceptable */
+
+	if (rp->mp_tracer == who_p) {
+		if (rp->mp_flags & TRACE_ZOMBIE) {
+			/* Traced child meets the pid test and has exited. */
+			tell_tracer(rp);
+			check_parent(rp, TRUE /*try_cleanup*/);
+			return(SUSPEND);
+		}
+		if (rp->mp_flags & TRACE_STOPPED) {
+			/* This child meets the pid test and is being traced.
+			 * Deliver a signal to the tracer, if any.
+			 */
+			for (i = 1; i < _NSIG; i++) {
+				if (sigismember(&rp->mp_sigtrace, i)) {
+					sigdelset(&rp->mp_sigtrace, i);
+
+					mp->mp_reply.m_pm_lc_waitpid.status = W_STOPCODE(i);
+					return(rp->mp_pid);
+				}
+			}
+		}
+	}
+
+	if (rp->mp_parent == who_p) {
+		if (rp->mp_flags & ZOMBIE) {
+			/* This child meets the pid test and has exited. */
+			tell_parent(rp); /* this child has already exited */
+			if (!(rp->mp_flags & VFS_CALL))
+				cleanup(rp);
+			return(SUSPEND);
+		}
+	}
+  }
+
+  /* No qualifying child has exited.  Wait for one, unless none exists. */
+  if (children > 0) {
+	/* At least 1 child meets the pid test exists, but has not exited. */
+	if (options & WNOHANG) {
+		return(0);    /* parent does not want to wait */
+	}
+	mp->mp_flags |= WAITING;	     /* parent wants to wait */
+	mp->mp_wpid = (pid_t) pidarg;	     /* save pid for later */
+	return(SUSPEND);		     /* do not reply, let it wait */
+  } else {
+	/* No child even meets the pid test.  Return error immediately. */
+	return(ECHILD);			     /* no - parent has no children */
+  }
+}
+
+/*===========================================================================*
+ *				wait_test				     *
+ *===========================================================================*/
+int wait_test(rmp, child)
+struct mproc *rmp;			/* process that may be waiting */
+struct mproc *child;			/* process that may be waited for */
+{
+/* See if a parent or tracer process is waiting for a child process.
+ * A tracer is considered to be a pseudo-parent.
+ */
+  int parent_waiting, right_child;
+  pid_t pidarg;
+
+  pidarg = rmp->mp_wpid;		/* who's being waited for? */
+  parent_waiting = rmp->mp_flags & WAITING;
+  right_child =				/* child meets one of the 3 tests? */
+  	(pidarg == -1 || pidarg == child->mp_pid ||
+  	 -pidarg == child->mp_procgrp);
+
+  return (parent_waiting && right_child);
+}
+
+/*===========================================================================*
+ *				zombify					     *
+ *===========================================================================*/
+static void zombify(rmp)
+struct mproc *rmp;
+{
+/* Zombify a process. First check if the exiting process is traced by a process
+ * other than its parent; if so, the tracer must be notified about the exit
+ * first. Once that is done, the real parent may be notified about the exit of
+ * its child.
+ */
+  struct mproc *t_mp;
+
+  if (rmp->mp_flags & (TRACE_ZOMBIE | ZOMBIE))
+	panic("zombify: process was already a zombie");
+
+  /* See if we have to notify a tracer process first. */
+  if (rmp->mp_tracer != NO_TRACER && rmp->mp_tracer != rmp->mp_parent) {
+	rmp->mp_flags |= TRACE_ZOMBIE;
+
+	t_mp = &mproc[rmp->mp_tracer];
+
+	/* Do not bother sending SIGCHLD signals to tracers. */
+	if (!wait_test(t_mp, rmp))
+		return;
+
+	tell_tracer(rmp);
+  }
+  else {
+	rmp->mp_flags |= ZOMBIE;
+  }
+
+  /* No tracer, or tracer is parent, or tracer has now been notified. */
+  check_parent(rmp, FALSE /*try_cleanup*/);
+}
+
+/*===========================================================================*
+ *				check_parent				     *
+ *===========================================================================*/
+static void check_parent(child, try_cleanup)
+struct mproc *child;			/* tells which process is exiting */
+int try_cleanup;			/* clean up the child when done? */
+{
+/* We would like to inform the parent of an exiting child about the child's
+ * death. If the parent is waiting for the child, tell it immediately;
+ * otherwise, send it a SIGCHLD signal.
+ *
+ * Note that we may call this function twice on a single child; first with
+ * its original parent, later (if the parent died) with INIT as its parent.
+ */
+  struct mproc *p_mp;
+
+  p_mp = &mproc[child->mp_parent];
+
+  if (p_mp->mp_flags & EXITING) {
+	/* This may trigger if the child of a dead parent dies. The child will
+	 * be assigned to INIT and rechecked shortly after. Do nothing.
+	 */
+  }
+  else if (wait_test(p_mp, child)) {
+	tell_parent(child);
+
+	/* The 'try_cleanup' flag merely saves us from having to be really
+	 * careful with statement ordering in exit_proc() and exit_restart().
+	 */
+	if (try_cleanup && !(child->mp_flags & VFS_CALL))
+		cleanup(child);
+  }
+  else {
+	/* Parent is not waiting. */
+	sig_proc(p_mp, SIGCHLD, TRUE /*trace*/, FALSE /* ksig */);
+  }
+}
+
+/*===========================================================================*
+ *				tell_parent				     *
+ *===========================================================================*/
+static void tell_parent(child)
+register struct mproc *child;	/* tells which process is exiting */
+{
+  int mp_parent;
+  struct mproc *parent;
+
+  mp_parent= child->mp_parent;
+  if (mp_parent <= 0)
+	panic("tell_parent: bad value in mp_parent: %d", mp_parent);
+  if(!(child->mp_flags & ZOMBIE))
+  	panic("tell_parent: child not a zombie");
+  if(child->mp_flags & TOLD_PARENT)
+	panic("tell_parent: telling parent again");
+  parent = &mproc[mp_parent];
+
+  /* Wake up the parent by sending the reply message. */
+  parent->mp_reply.m_pm_lc_waitpid.status =
+	W_EXITCODE(child->mp_exitstatus, child->mp_sigstatus);
+  reply(child->mp_parent, child->mp_pid);
+  parent->mp_flags &= ~WAITING;		/* parent no longer waiting */
+  child->mp_flags &= ~ZOMBIE;		/* child no longer a zombie */
+  child->mp_flags |= TOLD_PARENT;	/* avoid informing parent twice */
+}
+
+/*===========================================================================*
+ *				tell_tracer				     *
+ *===========================================================================*/
+static void tell_tracer(child)
+struct mproc *child;			/* tells which process is exiting */
+{
+  int mp_tracer;
+  struct mproc *tracer;
+
+  mp_tracer = child->mp_tracer;
+  if (mp_tracer <= 0)
+	panic("tell_tracer: bad value in mp_tracer: %d", mp_tracer);
+  if(!(child->mp_flags & TRACE_ZOMBIE))
+  	panic("tell_tracer: child not a zombie");
+  tracer = &mproc[mp_tracer];
+
+  tracer->mp_reply.m_pm_lc_waitpid.status =
+	W_EXITCODE(child->mp_exitstatus, (child->mp_sigstatus & 0377));
+  reply(child->mp_tracer, child->mp_pid);
+  tracer->mp_flags &= ~WAITING;		/* tracer no longer waiting */
+  child->mp_flags &= ~TRACE_ZOMBIE;	/* child no longer zombie to tracer */
+  child->mp_flags |= ZOMBIE;		/* child is now zombie to parent */
+}
+
+/*===========================================================================*
+ *				tracer_died				     *
+ *===========================================================================*/
+static void tracer_died(child)
+struct mproc *child;			/* process being traced */
+{
+/* The process that was tracing the given child, has died for some reason.
+ * This is really the tracer's fault, but we can't let INIT deal with this.
+ */
+
+  child->mp_tracer = NO_TRACER;
+  child->mp_flags &= ~TRACE_EXIT;
+
+  /* If the tracer died while the child was running or stopped, we have no
+   * idea what state the child is in. Avoid a trainwreck, by killing the child.
+   * Note that this may cause cascading exits.
+   */
+  if (!(child->mp_flags & EXITING)) {
+	sig_proc(child, SIGKILL, TRUE /*trace*/, FALSE /* ksig */);
+
+	return;
+  }
+
+  /* If the tracer died while the child was telling it about its own death,
+   * forget about the tracer and notify the real parent instead.
+   */
+  if (child->mp_flags & TRACE_ZOMBIE) {
+	child->mp_flags &= ~TRACE_ZOMBIE;
+	child->mp_flags |= ZOMBIE;
+
+	check_parent(child, TRUE /*try_cleanup*/);
+  }
+}
+
+/*===========================================================================*
+ *				cleanup					     *
+ *===========================================================================*/
+static void cleanup(rmp)
+register struct mproc *rmp;	/* tells which process is exiting */
+{
+  /* Release the process table entry and reinitialize some field. */
+  rmp->mp_pid = 0;
+  rmp->mp_flags = 0;
+  rmp->mp_child_utime = 0;
+  rmp->mp_child_stime = 0;
+  rmp->mp_money = INIT_BALANCE;
+  procs_in_use--;
+}
+
diff -rupNEZbB syf/usr/usr/src/minix/servers/pm/main.c syf/usr_new/usr/src/minix/servers/pm/main.c
--- syf/usr/usr/src/minix/servers/pm/main.c	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/servers/pm/main.c	2023-05-14 17:18:51.151811986 +0200
@@ -0,0 +1,413 @@
+/* This file contains the main program of the process manager and some related
+ * procedures.  When MINIX starts up, the kernel runs for a little while,
+ * initializing itself and its tasks, and then it runs PM and VFS.  Both PM
+ * and VFS initialize themselves as far as they can. PM asks the kernel for
+ * all free memory and starts serving requests.
+ *
+ * The entry points into this file are:
+ *   main:	starts PM running
+ *   reply:	send a reply to a process making a PM system call
+ */
+
+#include "pm.h"
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <minix/ds.h>
+#include <minix/type.h>
+#include <minix/endpoint.h>
+#include <minix/minlib.h>
+#include <minix/type.h>
+#include <minix/vm.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <sys/wait.h>
+#include <machine/archtypes.h>
+#include <env.h>
+#include <assert.h>
+#include "mproc.h"
+
+#include "kernel/const.h"
+#include "kernel/config.h"
+#include "kernel/proc.h"
+
+#if ENABLE_SYSCALL_STATS
+EXTERN unsigned long calls_stats[NR_PM_CALLS];
+#endif
+
+static int get_nice_value(int queue);
+static void handle_vfs_reply(void);
+
+/* SEF functions and variables. */
+static void sef_local_startup(void);
+static int sef_cb_init_fresh(int type, sef_init_info_t *info);
+
+/*===========================================================================*
+ *				main					     *
+ *===========================================================================*/
+int main()
+{
+/* Main routine of the process manager. */
+  unsigned int call_index;
+  int ipc_status, result;
+
+  /* SEF local startup. */
+  sef_local_startup();
+
+  /* This is PM's main loop-  get work and do it, forever and forever. */
+  while (TRUE) {
+	/* Wait for the next message. */
+	if (sef_receive_status(ANY, &m_in, &ipc_status) != OK)
+		panic("PM sef_receive_status error");
+
+	/* Check for system notifications first. Special cases. */
+	if (is_ipc_notify(ipc_status)) {
+		if (_ENDPOINT_P(m_in.m_source) == CLOCK)
+			expire_timers(m_in.m_notify.timestamp);
+
+		/* done, continue */
+		continue;
+	}
+
+	/* Extract useful information from the message. */
+	who_e = m_in.m_source;	/* who sent the message */
+	if (pm_isokendpt(who_e, &who_p) != OK)
+		panic("PM got message from invalid endpoint: %d", who_e);
+	mp = &mproc[who_p];	/* process slot of caller */
+	call_nr = m_in.m_type;	/* system call number */
+
+	/* Drop delayed calls from exiting processes. */
+	if (mp->mp_flags & EXITING)
+		continue;
+
+	if (IS_VFS_PM_RS(call_nr) && who_e == VFS_PROC_NR) {
+		handle_vfs_reply();
+
+		result = SUSPEND;		/* don't reply */
+	} else if (IS_PM_CALL(call_nr)) {
+		/* If the system call number is valid, perform the call. */
+		call_index = (unsigned int) (call_nr - PM_BASE);
+		if (call_index < NR_PM_CALLS && call_vec[call_index] != NULL) {
+#if ENABLE_SYSCALL_STATS
+			calls_stats[call_index]++;
+#endif
+			result = (*call_vec[call_index])();
+		} else
+			result = ENOSYS;
+	} else
+		result = ENOSYS;
+
+	/* Send reply. */
+	if (result != SUSPEND) reply(who_p, result);
+  }
+  return(OK);
+}
+
+/*===========================================================================*
+ *			       sef_local_startup			     *
+ *===========================================================================*/
+static void sef_local_startup()
+{
+  /* Register init callbacks. */
+  sef_setcb_init_fresh(sef_cb_init_fresh);
+  sef_setcb_init_restart(sef_cb_init_fail);
+
+  /* No live update support for now. */
+
+  /* Register signal callbacks. */
+  sef_setcb_signal_manager(process_ksig);
+
+  /* Let SEF perform startup. */
+  sef_startup();
+}
+
+/*===========================================================================*
+ *		            sef_cb_init_fresh                                *
+ *===========================================================================*/
+static int sef_cb_init_fresh(int UNUSED(type), sef_init_info_t *UNUSED(info))
+{
+/* Initialize the process manager. */
+  int s;
+  static struct boot_image image[NR_BOOT_PROCS];
+  register struct boot_image *ip;
+  static char core_sigs[] = { SIGQUIT, SIGILL, SIGTRAP, SIGABRT,
+				SIGEMT, SIGFPE, SIGBUS, SIGSEGV };
+  static char ign_sigs[] = { SIGCHLD, SIGWINCH, SIGCONT, SIGINFO };
+  static char noign_sigs[] = { SIGILL, SIGTRAP, SIGEMT, SIGFPE, 
+				SIGBUS, SIGSEGV };
+  register struct mproc *rmp;
+  register char *sig_ptr;
+  message mess;
+
+  /* Initialize process table, including timers. */
+  for (rmp=&mproc[0]; rmp<&mproc[NR_PROCS]; rmp++) {
+	init_timer(&rmp->mp_timer);
+	rmp->mp_magic = MP_MAGIC;
+	rmp->mp_money = INIT_BALANCE;
+  }
+
+  /* Build the set of signals which cause core dumps, and the set of signals
+   * that are by default ignored.
+   */
+  sigemptyset(&core_sset);
+  for (sig_ptr = core_sigs; sig_ptr < core_sigs+sizeof(core_sigs); sig_ptr++)
+	sigaddset(&core_sset, *sig_ptr);
+  sigemptyset(&ign_sset);
+  for (sig_ptr = ign_sigs; sig_ptr < ign_sigs+sizeof(ign_sigs); sig_ptr++)
+	sigaddset(&ign_sset, *sig_ptr);
+  sigemptyset(&noign_sset);
+  for (sig_ptr = noign_sigs; sig_ptr < noign_sigs+sizeof(noign_sigs); sig_ptr++)
+	sigaddset(&noign_sset, *sig_ptr);
+
+  /* Obtain a copy of the boot monitor parameters.
+   */
+  if ((s=sys_getmonparams(monitor_params, sizeof(monitor_params))) != OK)
+      panic("get monitor params failed: %d", s);
+
+  /* Initialize PM's process table. Request a copy of the system image table 
+   * that is defined at the kernel level to see which slots to fill in.
+   */
+  if (OK != (s=sys_getimage(image))) 
+  	panic("couldn't get image table: %d", s);
+  procs_in_use = 0;				/* start populating table */
+  for (ip = &image[0]; ip < &image[NR_BOOT_PROCS]; ip++) {
+  	if (ip->proc_nr >= 0) {			/* task have negative nrs */
+  		procs_in_use += 1;		/* found user process */
+
+		/* Set process details found in the image table. */
+		rmp = &mproc[ip->proc_nr];	
+  		strlcpy(rmp->mp_name, ip->proc_name, PROC_NAME_LEN); 
+  		(void) sigemptyset(&rmp->mp_ignore);	
+  		(void) sigemptyset(&rmp->mp_sigmask);
+  		(void) sigemptyset(&rmp->mp_catch);
+		if (ip->proc_nr == INIT_PROC_NR) {	/* user process */
+  			/* INIT is root, we make it father of itself. This is
+  			 * not really OK, INIT should have no father, i.e.
+  			 * a father with pid NO_PID. But PM currently assumes 
+  			 * that mp_parent always points to a valid slot number.
+  			 */
+  			rmp->mp_parent = INIT_PROC_NR;
+  			rmp->mp_procgrp = rmp->mp_pid = INIT_PID;
+			rmp->mp_flags |= IN_USE; 
+
+			/* Set scheduling info */
+			rmp->mp_scheduler = KERNEL;
+			rmp->mp_nice = get_nice_value(USR_Q);
+		}
+		else {					/* system process */
+  			if(ip->proc_nr == RS_PROC_NR) {
+  				rmp->mp_parent = INIT_PROC_NR;
+  			}
+  			else {
+  				rmp->mp_parent = RS_PROC_NR;
+  			}
+  			rmp->mp_pid = get_free_pid();
+			rmp->mp_flags |= IN_USE | PRIV_PROC;
+
+			/* RS schedules this process */
+			rmp->mp_scheduler = NONE;
+			rmp->mp_nice = get_nice_value(SRV_Q);
+		}
+
+		/* Get kernel endpoint identifier. */
+		rmp->mp_endpoint = ip->endpoint;
+
+		/* Tell VFS about this system process. */
+		memset(&mess, 0, sizeof(mess));
+		mess.m_type = VFS_PM_INIT;
+		mess.VFS_PM_SLOT = ip->proc_nr;
+		mess.VFS_PM_PID = rmp->mp_pid;
+		mess.VFS_PM_ENDPT = rmp->mp_endpoint;
+  		if (OK != (s=ipc_send(VFS_PROC_NR, &mess)))
+			panic("can't sync up with VFS: %d", s);
+  	}
+  }
+
+  /* Tell VFS that no more system processes follow and synchronize. */
+  memset(&mess, 0, sizeof(mess));
+  mess.m_type = VFS_PM_INIT;
+  mess.VFS_PM_ENDPT = NONE;
+  if (ipc_sendrec(VFS_PROC_NR, &mess) != OK || mess.m_type != OK)
+	panic("can't sync up with VFS");
+
+ system_hz = sys_hz();
+
+  /* Initialize user-space scheduling. */
+  sched_init();
+
+  return(OK);
+}
+
+/*===========================================================================*
+ *				reply					     *
+ *===========================================================================*/
+void reply(proc_nr, result)
+int proc_nr;			/* process to reply to */
+int result;			/* result of call (usually OK or error #) */
+{
+/* Send a reply to a user process.  System calls may occasionally fill in other
+ * fields, this is only for the main return value and for sending the reply.
+ */
+  struct mproc *rmp;
+  int r;
+
+  if(proc_nr < 0 || proc_nr >= NR_PROCS)
+      panic("reply arg out of range: %d", proc_nr);
+
+  rmp = &mproc[proc_nr];
+  rmp->mp_reply.m_type = result;
+
+  if ((r = ipc_sendnb(rmp->mp_endpoint, &rmp->mp_reply)) != OK)
+	printf("PM can't reply to %d (%s): %d\n", rmp->mp_endpoint,
+		rmp->mp_name, r);
+}
+
+/*===========================================================================*
+ *				get_nice_value				     *
+ *===========================================================================*/
+static int get_nice_value(queue)
+int queue;				/* store mem chunks here */
+{
+/* Processes in the boot image have a priority assigned. The PM doesn't know
+ * about priorities, but uses 'nice' values instead. The priority is between 
+ * MIN_USER_Q and MAX_USER_Q. We have to scale between PRIO_MIN and PRIO_MAX.
+ */ 
+  int nice_val = (queue - USER_Q) * (PRIO_MAX-PRIO_MIN+1) / 
+      (MIN_USER_Q-MAX_USER_Q+1);
+  if (nice_val > PRIO_MAX) nice_val = PRIO_MAX;	/* shouldn't happen */
+  if (nice_val < PRIO_MIN) nice_val = PRIO_MIN;	/* shouldn't happen */
+  return nice_val;
+}
+
+/*===========================================================================*
+ *				handle_vfs_reply       			     *
+ *===========================================================================*/
+static void handle_vfs_reply()
+{
+  struct mproc *rmp;
+  endpoint_t proc_e;
+  int r, proc_n, new_parent;
+
+  /* VFS_PM_REBOOT is the only request not associated with a process.
+   * Handle its reply first.
+   */
+  if (call_nr == VFS_PM_REBOOT_REPLY) {
+	/* Ask the kernel to abort. All system services, including
+	 * the PM, will get a HARD_STOP notification. Await the
+	 * notification in the main loop.
+	 */
+	sys_abort(abort_flag);
+
+	return;
+  }
+
+  /* Get the process associated with this call */
+  proc_e = m_in.VFS_PM_ENDPT;
+
+  if (pm_isokendpt(proc_e, &proc_n) != OK) {
+	panic("handle_vfs_reply: got bad endpoint from VFS: %d", proc_e);
+  }
+
+  rmp = &mproc[proc_n];
+
+  /* Now that VFS replied, mark the process as VFS-idle again */
+  if (!(rmp->mp_flags & VFS_CALL))
+	panic("handle_vfs_reply: reply without request: %d", call_nr);
+
+  new_parent = rmp->mp_flags & NEW_PARENT;
+  rmp->mp_flags &= ~(VFS_CALL | NEW_PARENT);
+
+  if (rmp->mp_flags & UNPAUSED)
+  	panic("handle_vfs_reply: UNPAUSED set on entry: %d", call_nr);
+
+  /* Call-specific handler code */
+  switch (call_nr) {
+  case VFS_PM_SETUID_REPLY:
+  case VFS_PM_SETGID_REPLY:
+  case VFS_PM_SETGROUPS_REPLY:
+	/* Wake up the original caller */
+	reply(rmp-mproc, OK);
+
+	break;
+
+  case VFS_PM_SETSID_REPLY:
+	/* Wake up the original caller */
+	reply(rmp-mproc, rmp->mp_procgrp);
+
+	break;
+
+  case VFS_PM_EXEC_REPLY:
+	exec_restart(rmp, m_in.VFS_PM_STATUS, (vir_bytes)m_in.VFS_PM_PC,
+		(vir_bytes)m_in.VFS_PM_NEWSP,
+		(vir_bytes)m_in.VFS_PM_NEWPS_STR);
+
+	break;
+
+  case VFS_PM_EXIT_REPLY:
+	exit_restart(rmp, FALSE /*dump_core*/);
+
+	break;
+
+  case VFS_PM_CORE_REPLY:
+	if (m_in.VFS_PM_STATUS == OK)
+		rmp->mp_sigstatus |= WCOREFLAG;
+
+	exit_restart(rmp, TRUE /*dump_core*/);
+
+	break;
+
+  case VFS_PM_FORK_REPLY:
+	/* Schedule the newly created process ... */
+	r = OK;
+	if (rmp->mp_scheduler != KERNEL && rmp->mp_scheduler != NONE) {
+		r = sched_start_user(rmp->mp_scheduler, rmp);
+	}
+
+	/* If scheduling the process failed, we want to tear down the process
+	 * and fail the fork */
+	if (r != OK) {
+		/* Tear down the newly created process */
+		rmp->mp_scheduler = NONE; /* don't try to stop scheduling */
+		exit_proc(rmp, -1, FALSE /*dump_core*/);
+
+		/* Wake up the parent with a failed fork (unless dead) */
+		if (!new_parent)
+			reply(rmp->mp_parent, -1);
+	}
+	else {
+		/* Wake up the child */
+		reply(proc_n, OK);
+
+		/* Wake up the parent, unless the parent is already dead */
+		if (!new_parent)
+			reply(rmp->mp_parent, rmp->mp_pid);
+	}
+
+	break;
+
+  case VFS_PM_SRV_FORK_REPLY:
+	/* Nothing to do */
+
+	break;
+
+  case VFS_PM_UNPAUSE_REPLY:
+	/* The target process must always be stopped while unpausing; otherwise
+	 * it could just end up pausing itself on a new call afterwards.
+	 */
+	assert(rmp->mp_flags & PROC_STOPPED);
+
+	/* Process is now unpaused */
+	rmp->mp_flags |= UNPAUSED;
+
+	break;
+
+  default:
+	panic("handle_vfs_reply: unknown reply code: %d", call_nr);
+  }
+
+  /* Now that the process is idle again, look at pending signals */
+  if ((rmp->mp_flags & (IN_USE | EXITING)) == IN_USE)
+	  restart_sigs(rmp);
+}
diff -rupNEZbB syf/usr/usr/src/minix/servers/pm/Makefile syf/usr_new/usr/src/minix/servers/pm/Makefile
--- syf/usr/usr/src/minix/servers/pm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/servers/pm/Makefile	2023-05-13 20:34:16.354502050 +0200
@@ -0,0 +1,17 @@
+.include <bsd.own.mk>
+
+# Makefile for Process Manager (PM)
+PROG=	pm
+SRCS=	main.c forkexit.c exec.c time.c alarm.c \
+	signal.c utility.c table.c trace.c getset.c misc.c \
+	profile.c mcontext.c schedule.c do_transfermoney.c
+
+DPADD+=	${LIBSYS} ${LIBTIMERS}
+LDADD+=	-lsys -ltimers
+
+CPPFLAGS.main.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.misc.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.schedule.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.utility.c+=	-I${NETBSDSRCDIR}/minix
+
+.include <minix.service.mk>
diff -rupNEZbB syf/usr/usr/src/minix/servers/pm/mproc.h syf/usr_new/usr/src/minix/servers/pm/mproc.h
--- syf/usr/usr/src/minix/servers/pm/mproc.h	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/servers/pm/mproc.h	2023-05-14 14:44:13.765107106 +0200
@@ -0,0 +1,97 @@
+/* This table has one slot per process.  It contains all the process management
+ * information for each process.  Among other things, it defines the text, data
+ * and stack segments, uids and gids, and various flags.  The kernel and file
+ * systems have tables that are also indexed by process, with the contents
+ * of corresponding slots referring to the same process in all three.
+ */
+#include <limits.h>
+#include <minix/timers.h>
+#include <signal.h>
+
+#include <sys/cdefs.h>
+
+/* Needs to be included here, for 'ps' etc */
+#include "const.h"
+
+EXTERN struct mproc {
+  char mp_exitstatus;		/* storage for status when process exits */
+  char mp_sigstatus;		/* storage for signal # for killed procs */
+  pid_t mp_pid;			/* process id */
+  endpoint_t mp_endpoint;	/* kernel endpoint id */
+  pid_t mp_procgrp;		/* pid of process group (used for signals) */
+  pid_t mp_wpid;		/* pid this process is waiting for */
+  int mp_parent;		/* index of parent process */
+  int mp_tracer;		/* index of tracer process, or NO_TRACER */
+
+  /* Child user and system times. Accounting done on child exit. */
+  clock_t mp_child_utime;	/* cumulative user time of children */
+  clock_t mp_child_stime;	/* cumulative sys time of children */
+
+  /* Real and effective uids and gids. */
+  uid_t mp_realuid;		/* process' real uid */
+  uid_t mp_effuid;		/* process' effective uid */
+  gid_t mp_realgid;		/* process' real gid */
+  gid_t mp_effgid;		/* process' effective gid */
+
+  /* Supplemental groups. */
+  int mp_ngroups;		/* number of supplemental groups */
+  gid_t mp_sgroups[NGROUPS_MAX];/* process' supplemental groups */
+
+  /* Signal handling information. */
+  sigset_t mp_ignore;		/* 1 means ignore the signal, 0 means don't */
+  sigset_t mp_catch;		/* 1 means catch the signal, 0 means don't */
+  sigset_t mp_sigmask;		/* signals to be blocked */
+  sigset_t mp_sigmask2;		/* saved copy of mp_sigmask */
+  sigset_t mp_sigpending;	/* pending signals to be handled */
+  sigset_t mp_ksigpending;	/* bitmap for pending signals from the kernel */
+  sigset_t mp_sigtrace;		/* signals to hand to tracer first */
+  struct sigaction mp_sigact[_NSIG]; /* as in sigaction(2) */
+#ifdef __ACK__
+  char mp_padding[60];		/* align structure with new libc */
+#endif
+  vir_bytes mp_sigreturn; 	/* address of C library __sigreturn function */
+  minix_timer_t mp_timer;	/* watchdog timer for alarm(2), setitimer(2) */
+  clock_t mp_interval[NR_ITIMERS];	/* setitimer(2) repetition intervals */
+
+  unsigned mp_flags;		/* flag bits */
+  unsigned mp_trace_flags;	/* trace options */
+  message mp_reply;		/* reply message to be sent to one */
+
+  /* Process execution frame. Both fields are used by procfs. */
+  vir_bytes mp_frame_addr;	/* ptr to proc's initial stack arguments */
+  size_t mp_frame_len;		/* size of proc's initial stack arguments */
+
+  /* Scheduling priority. */
+  signed int mp_nice;		/* nice is PRIO_MIN..PRIO_MAX, standard 0. */
+
+  /* User space scheduling */
+  endpoint_t mp_scheduler;	/* scheduler endpoint id */
+
+  char mp_name[PROC_NAME_LEN];	/* process name */
+
+  int mp_magic;			/* sanity check, MP_MAGIC */
+
+  int mp_money;			/* storage for process money */
+} mproc[NR_PROCS];
+
+/* Flag values */
+#define IN_USE		0x00001	/* set when 'mproc' slot in use */
+#define WAITING		0x00002	/* set by WAITPID system call */
+#define ZOMBIE		0x00004	/* waiting for parent to issue WAITPID call */
+#define PROC_STOPPED	0x00008	/* process is stopped in the kernel */
+#define ALARM_ON	0x00010	/* set when SIGALRM timer started */
+#define EXITING		0x00020	/* set by EXIT, process is now exiting */
+#define TOLD_PARENT	0x00040	/* parent wait() completed, ZOMBIE off */
+#define TRACE_STOPPED	0x00080	/* set if process stopped for tracing */
+#define SIGSUSPENDED	0x00100	/* set by SIGSUSPEND system call */
+#define VFS_CALL       	0x00400	/* set if waiting for VFS (normal calls) */
+#define NEW_PARENT	0x00800	/* process's parent changed during VFS call */
+#define UNPAUSED	0x01000	/* VFS has replied to unpause request */
+#define PRIV_PROC	0x02000	/* system process, special privileges */
+#define PARTIAL_EXEC	0x04000	/* process got a new map but no content */
+#define TRACE_EXIT	0x08000	/* tracer is forcing this process to exit */
+#define TRACE_ZOMBIE	0x10000	/* waiting for tracer to issue WAITPID call */
+#define DELAY_CALL	0x20000	/* waiting for call before sending signal */
+#define TAINTED		0x40000 /* process is 'tainted' */
+
+#define MP_MAGIC	0xC0FFEE0
diff -rupNEZbB syf/usr/usr/src/minix/servers/pm/pm.h syf/usr_new/usr/src/minix/servers/pm/pm.h
--- syf/usr/usr/src/minix/servers/pm/pm.h	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/servers/pm/pm.h	2023-05-14 16:24:33.465328871 +0200
@@ -0,0 +1,28 @@
+/* This is the master header for PM.  It includes some other files
+ * and defines the principal constants.
+ */
+#define _SYSTEM		1	/* tell headers that this is the kernel */
+
+/* The following are so basic, all the *.c files get them automatically. */
+#include <minix/config.h>	/* MUST be first */
+#include <sys/types.h>
+#include <minix/const.h>
+#include <minix/type.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <minix/timers.h>
+#include <minix/param.h>
+#include <minix/callnr.h>
+
+#include <limits.h>
+#include <errno.h>
+#include <sys/param.h>
+
+#include "const.h"
+#include "type.h"
+#include "proto.h"
+#include "glo.h"
diff -rupNEZbB syf/usr/usr/src/minix/servers/pm/proto.h syf/usr_new/usr/src/minix/servers/pm/proto.h
--- syf/usr/usr/src/minix/servers/pm/proto.h	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/servers/pm/proto.h	2023-05-14 10:54:17.800983977 +0200
@@ -0,0 +1,94 @@
+/* Function prototypes. */
+
+struct mproc;
+
+#include <minix/timers.h>
+
+/* alarm.c */
+int do_itimer(void);
+void set_alarm(struct mproc *rmp, clock_t ticks);
+void check_vtimer(int proc_nr, int sig);
+
+/* exec.c */
+int do_exec(void);
+int do_newexec(void);
+int do_execrestart(void);
+void exec_restart(struct mproc *rmp, int result, vir_bytes pc, vir_bytes sp,
+	vir_bytes ps_str);
+
+/* forkexit.c */
+int do_fork(void);
+int do_srv_fork(void);
+int do_exit(void);
+void exit_proc(struct mproc *rmp, int exit_status, int dump_core);
+void exit_restart(struct mproc *rmp, int dump_core);
+int do_waitpid(void);
+int wait_test(struct mproc *rmp, struct mproc *child);
+
+/* getset.c */
+int do_get(void);
+int do_set(void);
+
+/* main.c */
+int main(void);
+void reply(int proc_nr, int result);
+
+/* mcontext.c */
+int do_getmcontext(void);
+int do_setmcontext(void);
+
+/* misc.c */
+int do_reboot(void);
+int do_sysuname(void);
+int do_getsysinfo(void);
+int do_getprocnr(void);
+int do_getepinfo(void);
+int do_svrctl(void);
+int do_getsetpriority(void);
+int do_getrusage(void);
+
+/* schedule.c */
+void sched_init(void);
+int sched_start_user(endpoint_t ep, struct mproc *rmp);
+int sched_nice(struct mproc *rmp, int nice);
+
+/* profile.c */
+int do_sprofile(void);
+int do_cprofile(void);
+
+/* signal.c */
+int do_kill(void);
+int do_srv_kill(void);
+int process_ksig(endpoint_t proc_nr_e, int signo);
+int check_sig(pid_t proc_id, int signo, int ksig);
+void sig_proc(struct mproc *rmp, int signo, int trace, int ksig);
+int do_sigaction(void);
+int do_sigpending(void);
+int do_sigprocmask(void);
+int do_sigreturn(void);
+int do_sigsuspend(void);
+void check_pending(struct mproc *rmp);
+void restart_sigs(struct mproc *rmp);
+void vm_notify_sig_wrapper(endpoint_t ep);
+
+/* time.c */
+int do_stime(void);
+int do_time(void);
+int do_getres(void);
+int do_gettime(void);
+int do_settime(void);
+
+/* trace.c */
+int do_trace(void);
+void trace_stop(struct mproc *rmp, int signo);
+
+/* utility.c */
+pid_t get_free_pid(void);
+char *find_param(const char *key);
+struct mproc *find_proc(pid_t lpid);
+int nice_to_priority(int nice, unsigned *new_q);
+int pm_isokendpt(int ep, int *proc);
+void tell_vfs(struct mproc *rmp, message *m_ptr);
+
+/* do_transfermoney.c */
+int do_transfermoney(void);
diff -rupNEZbB syf/usr/usr/src/minix/servers/pm/table.c syf/usr_new/usr/src/minix/servers/pm/table.c
--- syf/usr/usr/src/minix/servers/pm/table.c	1970-01-01 01:00:00.000000000 +0100
+++ syf/usr_new/usr/src/minix/servers/pm/table.c	2023-05-14 17:07:24.355505082 +0200
@@ -0,0 +1,63 @@
+/* This file contains the table used to map system call numbers onto the
+ * routines that perform them.
+ */
+
+#define _TABLE
+
+#include "pm.h"
+#include <minix/callnr.h>
+#include <signal.h>
+#include "mproc.h"
+
+#define CALL(n)	[((n) - PM_BASE)]
+
+int (* const call_vec[NR_PM_CALLS])(void) = {
+	CALL(PM_EXIT)		= do_exit,		/* _exit(2) */
+	CALL(PM_FORK)		= do_fork,		/* fork(2) */
+	CALL(PM_WAITPID)	= do_waitpid,		/* waitpid(2) */
+	CALL(PM_GETPID)		= do_get,		/* get[p]pid(2) */
+	CALL(PM_SETUID)		= do_set,		/* setuid(2) */
+	CALL(PM_GETUID)		= do_get,		/* get[e]uid(2) */
+	CALL(PM_STIME)		= do_stime,		/* stime(2) */
+	CALL(PM_PTRACE)		= do_trace,		/* ptrace(2) */
+	CALL(PM_SETGROUPS)	= do_set,		/* setgroups(2) */
+	CALL(PM_GETGROUPS)	= do_get,		/* getgroups(2) */
+	CALL(PM_KILL)		= do_kill,		/* kill(2) */
+	CALL(PM_SETGID)		= do_set,		/* setgid(2) */
+	CALL(PM_GETGID)		= do_get,		/* get[e]gid(2) */
+	CALL(PM_EXEC)		= do_exec,		/* execve(2) */
+	CALL(PM_SETSID)		= do_set,		/* setsid(2) */
+	CALL(PM_GETPGRP)	= do_get,		/* getpgrp(2) */
+	CALL(PM_ITIMER)		= do_itimer,		/* [gs]etitimer(2) */
+	CALL(PM_GETMCONTEXT)	= do_getmcontext,	/* getmcontext(2) */
+	CALL(PM_SETMCONTEXT)	= do_setmcontext,	/* setmcontext(2) */
+	CALL(PM_SIGACTION)	= do_sigaction,		/* sigaction(2) */
+	CALL(PM_SIGSUSPEND)	= do_sigsuspend,	/* sigsuspend(2) */
+	CALL(PM_SIGPENDING)	= do_sigpending,	/* sigpending(2) */
+	CALL(PM_SIGPROCMASK)	= do_sigprocmask,	/* sigprocmask(2) */
+	CALL(PM_SIGRETURN)	= do_sigreturn,		/* sigreturn(2) */
+	CALL(PM_SYSUNAME)	= do_sysuname,		/* sysuname(2) */
+	CALL(PM_GETPRIORITY)	= do_getsetpriority,	/* getpriority(2) */
+	CALL(PM_SETPRIORITY)	= do_getsetpriority,	/* setpriority(2) */
+	CALL(PM_GETTIMEOFDAY)	= do_time,		/* gettimeofday(2) */
+	CALL(PM_SETEUID)	= do_set,		/* geteuid(2) */
+	CALL(PM_SETEGID)	= do_set,		/* setegid(2) */
+	CALL(PM_ISSETUGID)	= do_get,		/* issetugid */
+	CALL(PM_GETSID)		= do_get,		/* getsid(2) */
+	CALL(PM_CLOCK_GETRES)	= do_getres,		/* clock_getres(2) */
+	CALL(PM_CLOCK_GETTIME)	= do_gettime,		/* clock_gettime(2) */
+	CALL(PM_CLOCK_SETTIME)	= do_settime,		/* clock_settime(2) */
+	CALL(PM_GETRUSAGE)	= do_getrusage,		/* getrusage(2) */
+	CALL(PM_REBOOT)		= do_reboot,		/* reboot(2) */
+	CALL(PM_SVRCTL)		= do_svrctl,		/* svrctl(2) */
+	CALL(PM_SPROF)		= do_sprofile,		/* sprofile(2) */
+	CALL(PM_CPROF)		= do_cprofile,		/* cprofile(2) */
+	CALL(PM_SRV_FORK)	= do_srv_fork,		/* srv_fork(2) */
+	CALL(PM_SRV_KILL)	= do_srv_kill,		/* srv_kill(2) */
+	CALL(PM_EXEC_NEW)	= do_newexec,
+	CALL(PM_EXEC_RESTART)	= do_execrestart,
+	CALL(PM_GETEPINFO)	= do_getepinfo,		/* getepinfo(2) */
+	CALL(PM_GETPROCNR)	= do_getprocnr,		/* getprocnr(2) */
+	CALL(PM_GETSYSINFO)	= do_getsysinfo,	/* getsysinfo(2) */
+	CALL(PM_TRANSFER_MONEY) = do_transfermoney	/* transfermoney(2) */
+};
